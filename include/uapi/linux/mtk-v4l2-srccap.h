/* SPDX-License-Identifier: ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause) */
/*
 * Copyright (c) 2020 MediaTek Inc.
 */

#ifndef __UAPI_MTK_V4L2_SRCCAP_H__
#define __UAPI_MTK_V4L2_SRCCAP_H__

#include <linux/videodev2.h>
#include <stdbool.h>

/* ============================================================================================== */
/* ------------------------------------------ Defines ------------------------------------------- */
/* ============================================================================================== */

/* ============================================================================================== */
/* ----------------------------------- extended color format ------------------------------------ */
/* ============================================================================================== */

/* ============================================================================================== */
/*   RGB fourcc character definition ------------------------------------ */
/*   x y _ _  , xy = */
/*			AR(ARGB)   AB(ABGR)	RA(RGBA)	BA(BGRA)	RG(RGB)	BG(BGR)*/
/*			ar(AGB CE) ab(ABGR CE) ra(RGBA CE) ba(BGRA CE) rg(RGB CE) bg(BGR CE)*/
/*			AR(ARGB)   AB(ABGR)	RA(RGBA)	BA(BGRA)		*/
/*			ar(AGB CE) ab(ABGR CE) ra(RGBA CE) ba(BGRA CE)	*/
/*   _ _ z _  , z = 8(888/8888) A(101010/2101010) C(121212)			*/
/*   _ _ _ w  , w = P(planar) ' '(none)								*/
/* ============================================================================================== */

/* 3 plane contiguous RGB */
#define V4L2_PIX_FMT_RGB_8_8_8_CE		v4l2_fourcc('r', 'g', '8', 'P')

/* 1 plane RGB */
#define V4L2_PIX_FMT_RGB888			v4l2_fourcc('R', 'G', '8', ' ')
#define V4L2_PIX_FMT_RGB101010			v4l2_fourcc('R', 'G', 'A', ' ')
#define V4L2_PIX_FMT_RGB121212			v4l2_fourcc('R', 'G', 'C', ' ')

#define V4L2_PIX_FMT_ARGB8888			v4l2_fourcc('A', 'R', '8', ' ')
#define V4L2_PIX_FMT_ABGR8888			v4l2_fourcc('A', 'B', '8', ' ')
#define V4L2_PIX_FMT_RGBA8888			v4l2_fourcc('R', 'A', '8', ' ')
#define V4L2_PIX_FMT_BGRA8888			v4l2_fourcc('B', 'A', '8', ' ')

#define V4L2_PIX_FMT_ARGB2101010		v4l2_fourcc('A', 'R', 'A', ' ')
#define V4L2_PIX_FMT_ABGR2101010		v4l2_fourcc('A', 'B', 'A', ' ')
#define V4L2_PIX_FMT_RGBA1010102		v4l2_fourcc('R', 'A', 'A', ' ')
#define V4L2_PIX_FMT_BGRA1010102		v4l2_fourcc('B', 'A', 'A', ' ')

/* =============================================================================*/
/*   YUV fourcc character definition				*/
/*   a _ _ _  , a = Y(YUV) U(UVY) V(VYU) y(YVU) u(UYV) v(VUY)	*/
/*   _ b _ _  , b = 4(444) 2(422) 0(420)						*/
/*   _ _ c _  , c = 6(YC6bit) 8(YC8bit) A(YC10bit) C(YC12bit) %(Y8bitC6bit)...	*/
/*   _ _ _ d  , d = C(compressed) P(planar) &(compressed & planar) ' '(none)	*/
/* =============================================================================*/

/* 3 plane contiguous YUV */
#define V4L2_PIX_FMT_YUV444_Y_U_V_12B		v4l2_fourcc('Y', '4', 'C', 'P')
#define V4L2_PIX_FMT_YUV444_Y_U_V_10B		v4l2_fourcc('Y', '4', 'A', 'P')
#define V4L2_PIX_FMT_YUV444_Y_U_V_8B		v4l2_fourcc('Y', '4', '8', 'P')
#define V4L2_PIX_FMT_YUV444_Y_U_V_8B_CE		v4l2_fourcc('Y', '4', '8', '&')

/* 2 plane contiguous YUV */
#define V4L2_PIX_FMT_YUV422_Y_UV_12B		v4l2_fourcc('Y', '2', 'C', 'P')
#define V4L2_PIX_FMT_YUV422_Y_UV_10B		v4l2_fourcc('Y', '2', 'A', 'P')
#define V4L2_PIX_FMT_YUV422_Y_UV_8B_CE		v4l2_fourcc('Y', '2', '8', '&')
#define V4L2_PIX_FMT_YUV422_Y_UV_8B_6B_CE	v4l2_fourcc('Y', '2', '%', '&')
#define V4L2_PIX_FMT_YUV422_Y_UV_6B_CE		v4l2_fourcc('Y', '2', '6', '&')

#define V4L2_PIX_FMT_YUV420_Y_UV_10B		v4l2_fourcc('Y', '0', 'A', 'P')
#define V4L2_PIX_FMT_YUV420_Y_UV_8B_CE		v4l2_fourcc('Y', '0', '8', '&')
#define V4L2_PIX_FMT_YUV420_Y_UV_8B_6B_CE	v4l2_fourcc('Y', '0', '%', '&')
#define V4L2_PIX_FMT_YUV420_Y_UV_6B_CE		v4l2_fourcc('Y', '0', '6', '&')

/* 1 plane YUV */
#define V4L2_PIX_FMT_YUV444_YUV_12B		v4l2_fourcc('Y', '4', 'C', ' ')
#define V4L2_PIX_FMT_YUV444_YUV_10B		v4l2_fourcc('Y', '4', 'A', ' ')

#define V4L2_PIX_FMT_YUV422_YUV_12B		v4l2_fourcc('Y', '2', 'C', ' ')
#define V4L2_PIX_FMT_YUV422_YUV_10B		v4l2_fourcc('Y', '2', 'A', ' ')

#define V4L2_PIX_FMT_YUV420_YUV_10B		v4l2_fourcc('Y', '0', 'A', ' ')

/* ============================================================================================== */
/* ------------------------------------------- Macros ------------------------------------------- */
/* ============================================================================================== */
#define	_BIT(shifts) (1 << (shifts))

/* ============================================================================================== */
/* ------------------------------------------ Ctrl IDs ------------------------------------------ */
/* ============================================================================================== */
#define SRCCAP_BASE					(V4L2_CID_USER_BASE + 0x2000)
#define SRCCAP_ADC_BASE					(SRCCAP_BASE + 0x100)
#define SRCCAP_AVD_BASE					(SRCCAP_BASE + 0x300)
#define SRCCAP_COMMON_BASE				(SRCCAP_BASE + 0x500)
#define SRCCAP_DSCL_BASE				(SRCCAP_BASE + 0x700)
#define SRCCAP_HDMIRX_BASE				(SRCCAP_BASE + 0x900)
#define SRCCAP_MEMOUT_BASE				(SRCCAP_BASE + 0xB00)
#define SRCCAP_MUX_BASE					(SRCCAP_BASE + 0xD00)
#define SRCCAP_OD_BASE					(SRCCAP_BASE + 0xF00)
#define SRCCAP_TIMINGDETECT_BASE			(SRCCAP_BASE + 0x1000)
#define SRCCAP_VBI_BASE					(SRCCAP_BASE + 0x1100)

/* SRCCAP class control IDs */
#define V4L2_CID_SRCCAP_STUB				(SRCCAP_BASE + 0)
#define V4L2_CID_SRCCAP_HDMI_SYNC_STATUS		(SRCCAP_BASE + 1)
#define V4L2_CID_SRCCAP_HDMI2_SYNC_STATUS		(SRCCAP_BASE + 2)
#define V4L2_CID_SRCCAP_HDMI3_SYNC_STATUS		(SRCCAP_BASE + 3)
#define V4L2_CID_SRCCAP_HDMI4_SYNC_STATUS		(SRCCAP_BASE + 4)
#define V4L2_CID_SRCCAP_CVBS_SYNC_STATUS		(SRCCAP_BASE + 5)
#define V4L2_CID_SRCCAP_CVBS2_SYNC_STATUS		(SRCCAP_BASE + 6)
#define V4L2_CID_SRCCAP_CVBS3_SYNC_STATUS		(SRCCAP_BASE + 7)
#define V4L2_CID_SRCCAP_CVBS4_SYNC_STATUS		(SRCCAP_BASE + 8)
#define V4L2_CID_SRCCAP_CVBS5_SYNC_STATUS		(SRCCAP_BASE + 9)
#define V4L2_CID_SRCCAP_CVBS6_SYNC_STATUS		(SRCCAP_BASE + 10)
#define V4L2_CID_SRCCAP_CVBS7_SYNC_STATUS		(SRCCAP_BASE + 11)
#define V4L2_CID_SRCCAP_CVBS8_SYNC_STATUS		(SRCCAP_BASE + 12)
#define V4L2_CID_SRCCAP_SVIDEO_SYNC_STATUS		(SRCCAP_BASE + 13)
#define V4L2_CID_SRCCAP_SVIDEO2_SYNC_STATUS		(SRCCAP_BASE + 14)
#define V4L2_CID_SRCCAP_SVIDEO3_SYNC_STATUS		(SRCCAP_BASE + 15)
#define V4L2_CID_SRCCAP_SVIDEO4_SYNC_STATUS		(SRCCAP_BASE + 16)
#define V4L2_CID_SRCCAP_YPBPR_SYNC_STATUS		(SRCCAP_BASE + 17)
#define V4L2_CID_SRCCAP_YPBPR2_SYNC_STATUS		(SRCCAP_BASE + 18)
#define V4L2_CID_SRCCAP_YPBPR3_SYNC_STATUS		(SRCCAP_BASE + 19)
#define V4L2_CID_SRCCAP_VGA_SYNC_STATUS			(SRCCAP_BASE + 20)
#define V4L2_CID_SRCCAP_VGA2_SYNC_STATUS		(SRCCAP_BASE + 21)
#define V4L2_CID_SRCCAP_VGA3_SYNC_STATUS		(SRCCAP_BASE + 22)
#define V4L2_CID_SRCCAP_SCART_SYNC_STATUS		(SRCCAP_BASE + 23)
#define V4L2_CID_SRCCAP_SCART2_SYNC_STATUS		(SRCCAP_BASE + 24)
#define V4L2_CID_SRCCAP_BUFFER_HANDLING_TRIGGER		(SRCCAP_BASE + 25)

/* ADC class control IDs */
#define V4L2_CID_ADC_SOURCE				(SRCCAP_ADC_BASE + 0)
#define V4L2_CID_ADC_GAIN				(SRCCAP_ADC_BASE + 1)
#define V4L2_CID_ADC_OFFSET				(SRCCAP_ADC_BASE + 2)
#define V4L2_CID_ADC_PHASE				(SRCCAP_ADC_BASE + 3)
#define V4L2_CID_ADC_IS_SCARTRGB			(SRCCAP_ADC_BASE + 4)
#define V4L2_CID_ADC_AUTO_GAIN_OFFSET			(SRCCAP_ADC_BASE + 5)
#define V4L2_CID_ADC_AUTO_GEOMETRY			(SRCCAP_ADC_BASE + 6)

/* AVD class control IDs */
#define V4L2_CID_AVD_HSYNC_EDGE				(SRCCAP_AVD_BASE + 0)
#define V4L2_CID_AVD_FLAG				(SRCCAP_AVD_BASE + 1)
#define V4L2_CID_AVD_V_TOTAL				(SRCCAP_AVD_BASE + 2)
#define V4L2_CID_AVD_NOISE_MAG				(SRCCAP_AVD_BASE + 3)
#define V4L2_CID_AVD_IS_SYNCLOCKED			(SRCCAP_AVD_BASE + 4)
#define V4L2_CID_AVD_STANDARD_DETETION			(SRCCAP_AVD_BASE + 5)
#define V4L2_CID_AVD_STATUS				(SRCCAP_AVD_BASE + 6)
#define V4L2_CID_AVD_SCAN_HSYNC_CHECK			(SRCCAP_AVD_BASE + 7)
#define V4L2_CID_AVD_VERTICAL_FREQ			(SRCCAP_AVD_BASE + 8)
#define V4L2_CID_AVD_INFO				(SRCCAP_AVD_BASE + 9)
#define V4L2_CID_AVD_INIT				(SRCCAP_AVD_BASE + 10)
#define V4L2_CID_AVD_EXIT				(SRCCAP_AVD_BASE + 11)
#define V4L2_CID_AVD_INPUT				(SRCCAP_AVD_BASE + 12)
#define V4L2_CID_AVD_FORCE_VIDEO_STANDARD		(SRCCAP_AVD_BASE + 13)
#define V4L2_CID_AVD_VIDEO_STANDARD			(SRCCAP_AVD_BASE + 14)
#define V4L2_CID_AVD_FREERUN_FREQ			(SRCCAP_AVD_BASE + 15)
#define V4L2_CID_AVD_STILL_IMAGE_PARAM			(SRCCAP_AVD_BASE + 16)
#define V4L2_CID_AVD_FACTORY_PARA			(SRCCAP_AVD_BASE + 17)
#define V4L2_CID_AVD_3D_COMB_SPEED			(SRCCAP_AVD_BASE + 18)
#define V4L2_CID_AVD_3D_COMB				(SRCCAP_AVD_BASE + 19)
#define V4L2_CID_AVD_REG_FROM_DSP			(SRCCAP_AVD_BASE + 20)
#define V4L2_CID_AVD_HTT_USER_MD			(SRCCAP_AVD_BASE + 21)
#define V4L2_CID_AVD_HSYNC_DETECTION_FOR_TUNING		(SRCCAP_AVD_BASE + 22)
#define V4L2_CID_AVD_CHANNEL_CHANGE			(SRCCAP_AVD_BASE + 23)
#define V4L2_CID_AVD_MCU_RESET				(SRCCAP_AVD_BASE + 24)
#define V4L2_CID_AVD_START_AUTO_STANDARD_DETECTION	(SRCCAP_AVD_BASE + 25)
#define V4L2_CID_AVD_3D_COMB_SPEED_UP			(SRCCAP_AVD_BASE + 26)
#define V4L2_CID_AVD_IS_LOCK_AUDIO_CARRIER		(SRCCAP_AVD_BASE + 27)
#define V4L2_CID_AVD_ALIVE_CHECK			(SRCCAP_AVD_BASE + 28)
#define V4L2_CID_AVD_DSP_RESET				(SRCCAP_AVD_BASE + 29)

/* Common class control IDs */
#define V4L2_CID_COMMON_FORCE_VSYNC			(SRCCAP_COMMON_BASE + 0)
#define V4L2_CID_SRCCAP_PQMAP_INFO			(SRCCAP_COMMON_BASE + 1)

/* DSCL class control IDs */
#define V4L2_CID_DSCL_SETTING				(SRCCAP_DSCL_BASE + 0)

/* HDMIRX Class Control IDs */
#define V4L2_CID_HDMI_RX_HDCP22_IRQ_EANBLE		(SRCCAP_HDMIRX_BASE + 1)
#define V4L2_CID_HDMI_RX_HDCP22_PORTINIT		(SRCCAP_HDMIRX_BASE + 2)
#define V4L2_CID_HDMI_RX_HDCP22_SENDMSG			(SRCCAP_HDMIRX_BASE + 3)
#define V4L2_CID_HDMI_RX_HDCP14_R0IRQENABLE		(SRCCAP_HDMIRX_BASE + 4)
#define V4L2_CID_HDMI_RX_SET_EQ_TO_PORT			(SRCCAP_HDMIRX_BASE + 5)
#define V4L2_CID_HDMI_RX_AUDIO_STATUS_CLEAR		(SRCCAP_HDMIRX_BASE + 6)
#define V4L2_CID_HDMI_RX_HPD_CONTROL			(SRCCAP_HDMIRX_BASE + 7)
#define V4L2_CID_HDMI_RX_SW_RESET			(SRCCAP_HDMIRX_BASE + 8)
#define V4L2_CID_HDMI_RX_PKT_RESET			(SRCCAP_HDMIRX_BASE + 9)
#define V4L2_CID_HDMI_RX_CLKRTERM_CONTROL		(SRCCAP_HDMIRX_BASE + 10)
#define V4L2_CID_HDMI_RX_ARCPIN_CONTROL			(SRCCAP_HDMIRX_BASE + 11)
#define V4L2_CID_HDMI_RX_AUDIO_MUTE			(SRCCAP_HDMIRX_BASE + 12)
#define V4L2_CID_HDMI_RX_SET_CURRENT_PORT		(SRCCAP_HDMIRX_BASE + 13)
#define V4L2_CID_HDMI_RX_GET_IT_CONTENT_TYPE		(SRCCAP_HDMIRX_BASE + 14)
#define V4L2_CID_HDMI_RX_HDCP22_READDONE		(SRCCAP_HDMIRX_BASE + 15)
#define V4L2_CID_HDMI_RX_GET_GC_INFO			(SRCCAP_HDMIRX_BASE + 16)
#define V4L2_CID_HDMI_RX_GET_ERR_STATUS			(SRCCAP_HDMIRX_BASE + 17)
#define V4L2_CID_HDMI_RX_GET_ACP			(SRCCAP_HDMIRX_BASE + 18)
#define V4L2_CID_HDMI_RX_GET_PIXEL_REPETITION		(SRCCAP_HDMIRX_BASE + 19)
#define V4L2_CID_HDMI_RX_GET_AVI_VER			(SRCCAP_HDMIRX_BASE + 20)
#define V4L2_CID_HDMI_RX_GET_AVI_ACTIVEINFO		(SRCCAP_HDMIRX_BASE + 21)
#define V4L2_CID_HDMI_RX_ISHDMIMODE			(SRCCAP_HDMIRX_BASE + 22)
#define V4L2_CID_HDMI_RX_CHECK_4K2K			(SRCCAP_HDMIRX_BASE + 23)
#define V4L2_CID_HDMI_RX_CHECK_ADDITION_FMT		(SRCCAP_HDMIRX_BASE + 24)
#define V4L2_CID_HDMI_RX_GET_3D_STRUCTURE		(SRCCAP_HDMIRX_BASE + 25)
#define V4L2_CID_HDMI_RX_GET_3D_EXT_DATA		(SRCCAP_HDMIRX_BASE + 26)
#define V4L2_CID_HDMI_RX_GET_3D_META_FIELD		(SRCCAP_HDMIRX_BASE + 27)
#define V4L2_CID_HDMI_RX_GET_SOURCE_VER			(SRCCAP_HDMIRX_BASE + 28)
#define V4L2_CID_HDMI_RX_GET_DE_STABLE_STATUS		(SRCCAP_HDMIRX_BASE + 29)
#define V4L2_CID_HDMI_RX_GET_CRC			(SRCCAP_HDMIRX_BASE + 30)
#define V4L2_CID_HDMI_RX_GET_EMP			(SRCCAP_HDMIRX_BASE + 31)
#define V4L2_CID_HDMI_RX_CTRL				(SRCCAP_HDMIRX_BASE + 32)
#define V4L2_CID_HDMI_RX_SET_DITHER			(SRCCAP_HDMIRX_BASE + 33)
#define V4L2_CID_HDMI_RX_GET_FS				(SRCCAP_HDMIRX_BASE + 34)
#define V4L2_CID_HDMI_RX_HDCP22_GETMSG			(SRCCAP_HDMIRX_BASE + 35)
#define V4L2_CID_HDMI_RX_PKT_GET_AVI (SRCCAP_HDMIRX_BASE + 36)
#define V4L2_CID_HDMI_RX_PKT_GET_VSIF (SRCCAP_HDMIRX_BASE + 37)
#define V4L2_CID_HDMI_RX_PKT_GET_GCP (SRCCAP_HDMIRX_BASE + 38)
#define V4L2_CID_HDMI_RX_PKT_GET_HDRIF (SRCCAP_HDMIRX_BASE + 39)
#define V4L2_CID_HDMI_RX_PKT_GET_VS_EMP (SRCCAP_HDMIRX_BASE + 40)
#define V4L2_CID_HDMI_RX_PKT_GET_DSC_EMP (SRCCAP_HDMIRX_BASE + 41)
#define V4L2_CID_HDMI_RX_PKT_GET_DYNAMIC_HDR_EMP (SRCCAP_HDMIRX_BASE + 42)
#define V4L2_CID_HDMI_RX_PKT_GET_VRR_EMP (SRCCAP_HDMIRX_BASE + 43)
#define V4L2_CID_HDMI_RX_PKT_GET_REPORT (SRCCAP_HDMIRX_BASE + 44)
#define V4L2_CID_HDMI_RX_PKT_IS_DSC (SRCCAP_HDMIRX_BASE + 45)
#define V4L2_CID_HDMI_RX_PKT_IS_VRR (SRCCAP_HDMIRX_BASE + 46)
#define V4L2_CID_HDMI_RX_DSC_GET_PPS_INFO (SRCCAP_HDMIRX_BASE + 47)
#define V4L2_CID_HDMI_RX_MUX_SEL_DSC (SRCCAP_HDMIRX_BASE + 48)
#define V4L2_CID_HDMI_RX_MUX_QUERY_DSC (SRCCAP_HDMIRX_BASE + 49)
#define V4L2_CID_HDMI_RX_PKT_GET_GNL (SRCCAP_HDMIRX_BASE + 50)
#define V4L2_CID_HDMI_RX_GET_CABLE_DETECT (SRCCAP_HDMIRX_BASE + 51)
#define V4L2_CID_HDMI_RX_SET_SIM_MODE (SRCCAP_HDMIRX_BASE + 52)
#define V4L2_CID_HDMI_RX_SET_SIM_DATA (SRCCAP_HDMIRX_BASE + 53)
#define V4L2_CID_HDMI_RX_GET_SIM_MODE (SRCCAP_HDMIRX_BASE + 54)
#define V4L2_CID_HDMI_RX_GET_AUDIO_FS (SRCCAP_HDMIRX_BASE + 55)
#define V4L2_CID_HDMI_RX_SET_PWR_SAVING_ONOFF (SRCCAP_HDMIRX_BASE + 56)
#define V4L2_CID_HDMI_RX_GET_PWR_SAVING_ONOFF (SRCCAP_HDMIRX_BASE + 57)
#define V4L2_CID_HDMI_RX_GET_HDMI_STATUS (SRCCAP_HDMIRX_BASE + 58)
#define V4L2_CID_HDMI_RX_GET_FREESYNC_INFO (SRCCAP_HDMIRX_BASE + 59)

/* MemOut class control IDs */
#define V4L2_CID_MEMOUT_BUF_CTRL_MODE			(SRCCAP_MEMOUT_BASE + 0)
#define V4L2_CID_MEMOUT_SECURE_MODE			(SRCCAP_MEMOUT_BASE + 1)
#define V4L2_CID_MEMOUT_SECURE_SRC_TABLE		(SRCCAP_MEMOUT_BASE + 2)
#define V4L2_CID_MEMOUT_TIME_STAMP			(SRCCAP_MEMOUT_BASE + 3)

/* Mux class control IDs */

/* Timing Detect class control IDs */
#define V4L2_CID_TIMINGDETECT_STATUS			(SRCCAP_TIMINGDETECT_BASE + 0)
#define V4L2_CID_TIMINGDETECT_TIMING			(SRCCAP_TIMINGDETECT_BASE + 1)
#define V4L2_CID_TIMINGDETECT_VRR_ENFORCEMENT		(SRCCAP_TIMINGDETECT_BASE + 2)

/* VBI class control IDs */
#define V4L2_CID_VBI_INIT					(SRCCAP_VBI_BASE + 0)
#define V4L2_CID_VBI_EXIT					(SRCCAP_VBI_BASE + 1)
#define V4L2_CID_VBI_INIT_TTX_SLICER		 (SRCCAP_VBI_BASE + 2)
#define V4L2_CID_VBI_ENABLE_TTX_SLICER	   (SRCCAP_VBI_BASE + 3)
#define V4L2_CID_VBI_TTX_INFO				(SRCCAP_VBI_BASE + 4)
#define V4L2_CID_VBI_INIT_CC_SLICER		  (SRCCAP_VBI_BASE + 5)
#define V4L2_CID_VBI_CC_INFO				 (SRCCAP_VBI_BASE + 6)
#define V4L2_CID_VBI_CC_RATE				 (SRCCAP_VBI_BASE + 7)
#define V4L2_CID_VBI_TTX_OVERFLOW			(SRCCAP_VBI_BASE + 8)
#define V4L2_CID_VBI_TTX_RESET_BUF		   (SRCCAP_VBI_BASE + 9)
#define V4L2_CID_VBI_TTX_DATA				(SRCCAP_VBI_BASE + 10)
#define V4L2_CID_VBI_CC_FRAME_COUNT		  (SRCCAP_VBI_BASE + 11)
#define V4L2_CID_VBI_CC_ENABLE_SLICER		(SRCCAP_VBI_BASE + 12)
#define V4L2_CID_VBI_VPS_READY			   (SRCCAP_VBI_BASE + 13)
#define V4L2_CID_VBI_VPS_DATA				(SRCCAP_VBI_BASE + 14)
#define V4L2_CID_VBI_VPS_ALL_DATA			(SRCCAP_VBI_BASE + 15)
#define V4L2_CID_VBI_WSS_READY			   (SRCCAP_VBI_BASE + 16)
#define V4L2_CID_VBI_TTX_PKTCOUNT			(SRCCAP_VBI_BASE + 17)
#define V4L2_CID_VBI_WSS_DATA				(SRCCAP_VBI_BASE + 18)
#define V4L2_CID_VBI_WSS_PKTCOUNT			(SRCCAP_VBI_BASE + 19)
#define V4L2_CID_VBI_VIDEO_STANDARD		  (SRCCAP_VBI_BASE + 20)
#define V4L2_CID_VBI_GET_KERNEL_VA		   (SRCCAP_VBI_BASE + 21)

#define V4L2_EVENT_CTRL_CH_HDMI_RX_BASE				 0x8000
#define V4L2_EVENT_CTRL_CH_HDMI_RX_CABLE_DISCONNECT	 (V4L2_EVENT_CTRL_CH_HDMI_RX_BASE+1)
#define V4L2_EVENT_CTRL_CH_HDMI_RX_CABLE_CONNECT		(V4L2_EVENT_CTRL_CH_HDMI_RX_BASE+2)
#define V4L2_EVENT_CTRL_CH_HDMI_RX_DVI_MODE			 (V4L2_EVENT_CTRL_CH_HDMI_RX_BASE+3)
#define V4L2_EVENT_CTRL_CH_HDMI_RX_HDMI_MODE			(V4L2_EVENT_CTRL_CH_HDMI_RX_BASE+4)
#define V4L2_EVENT_CTRL_CH_HDMI_RX_HDCP2X_WRITE_DONE	(V4L2_EVENT_CTRL_CH_HDMI_RX_BASE+5)
#define V4L2_EVENT_CTRL_CH_HDMI_RX_HDCP2X_READ_DONE	 (V4L2_EVENT_CTRL_CH_HDMI_RX_BASE+6)
#define V4L2_EVENT_CTRL_CH_HDMI_RX_AVMUTE_CHANGE	 (V4L2_EVENT_CTRL_CH_HDMI_RX_BASE+_BIT(5))
#define V4L2_EVENT_CTRL_CH_HDMI_RX_AVI_CHANGE		   (V4L2_EVENT_CTRL_CH_HDMI_RX_BASE+_BIT(6))
#define V4L2_EVENT_CTRL_CH_HDMI_RX_RECEIVE_SPD		  (V4L2_EVENT_CTRL_CH_HDMI_RX_BASE+_BIT(7))
#define V4L2_EVENT_CTRL_CH_HDMI_RX_ALLM_CHANGE		  (V4L2_EVENT_CTRL_CH_HDMI_RX_BASE+_BIT(8))
#define V4L2_EVENT_CTRL_CH_HDMI_RX_RECEIVE_VS		   (V4L2_EVENT_CTRL_CH_HDMI_RX_BASE+_BIT(9))
#define V4L2_EVENT_CTRL_CH_HDMI_RX_RECEIVE_AUI		  (V4L2_EVENT_CTRL_CH_HDMI_RX_BASE+_BIT(10))
#define V4L2_EVENT_CTRL_CH_HDMI_RX_RECEIVE_MPEG		 (V4L2_EVENT_CTRL_CH_HDMI_RX_BASE+_BIT(11))

enum v4l2_ext_hdmi_ctrl_id {
	V4L2_EXT_HDMI_INTERFACE_CMD_GET_HDCP_STATE = 0x500,
	/*************************** HDCP Related ***************************/
	V4L2_EXT_HDMI_INTERFACE_CMD_WRITE_X74,
	V4L2_EXT_HDMI_INTERFACE_CMD_READ_X74,
	V4L2_EXT_HDMI_INTERFACE_CMD_SET_REPEATER,
	V4L2_EXT_HDMI_HDMI_INTERFACE_CMD_SET_BSTATUS,
	V4L2_EXT_HDMI_HDMI_INTERFACE_CMD_SET_HDMI_MODE,
	V4L2_EXT_HDMI_HDMI_INTERFACE_CMD_GET_INTERRUPT_STATUS,
	V4L2_EXT_HDMI_HDMI_INTERFACE_CMD_WRITE_KSV_LIST,
	V4L2_EXT_HDMI_HDMI_INTERFACE_CMD_SET_VPRIME,
	/*************************** HDCP Related ***************************/
	V4L2_EXT_HDMI_HDMI_INTERFACE_CMD_DATA_RTERM_CONTROL,
	V4L2_EXT_HDMI_HDMI_INTERFACE_CMD_GET_SCDC_VALUE,
	V4L2_EXT_HDMI_HDMI_INTERFACE_CMD_GET_TMDS_RATES_KHZ,
	V4L2_EXT_HDMI_HDMI_INTERFACE_CMD_GET_CABLE_DETECT,
	V4L2_EXT_HDMI_HDMI_INTERFACE_CMD_GET_PACKET_STATUS,
	V4L2_EXT_HDMI_HDMI_INTERFACE_CMD_GET_PACKET_CONTENT,
	V4L2_EXT_HDMI_HDMI_INTERFACE_CMD_GET_HDR_METADATA,
	V4L2_EXT_HDMI_HDMI_INTERFACE_CMD_GET_AVI_PARSING_INFO,
	V4L2_EXT_HDMI_HDMI_INTERFACE_CMD_GET_VS_PARSING_INFO,
	V4L2_EXT_HDMI_HDMI_INTERFACE_CMD_GET_GC_PARSING_INFO,
	V4L2_EXT_HDMI_HDMI_INTERFACE_CMD_GET_TIMING_INFO,
	V4L2_EXT_HDMI_HDMI_INTERFACE_CMD_GET_HDCP_AUTHVERSION,
	V4L2_EXT_HDMI_HDMI_INTERFACE_CMD_FORCE_POWER_DOWN,
};

/* ============================================================================================== */
/* ------------------------------------------- Events ------------------------------------------- */
/* ============================================================================================== */
#define SRCCAP_EVENT_START			(V4L2_EVENT_PRIVATE_START)
#define SRCCAP_ADC_EVENT_START			(V4L2_EVENT_PRIVATE_START | 0x1000)
#define SRCCAP_AVD_EVENT_START			(V4L2_EVENT_PRIVATE_START | 0x2000)
#define SRCCAP_COMMON_EVENT_START		(V4L2_EVENT_PRIVATE_START | 0x3000)
#define SRCCAP_DSCL_EVENT_START			(V4L2_EVENT_PRIVATE_START | 0x4000)
#define SRCCAP_HDMIRX_EVENT_START		(V4L2_EVENT_PRIVATE_START | 0x5000)
#define SRCCAP_MEMOUT_EVENT_START		(V4L2_EVENT_PRIVATE_START | 0x6000)
#define SRCCAP_MUX_EVENT_START			(V4L2_EVENT_PRIVATE_START | 0x7000)
#define SRCCAP_TIMINGDETECT_EVENT_START		(V4L2_EVENT_PRIVATE_START | 0x8000)
#define SRCCAP_VBI_EVENT_START			(V4L2_EVENT_PRIVATE_START | 0x9000)

/* SRCCAP events */
#define V4L2_SRCCAP_SUSPEND_EVENT		(SRCCAP_EVENT_START | 0x1)
#define V4L2_SRCCAP_RESUME_EVENT		(SRCCAP_EVENT_START | 0x2)

/* ADC events */

/* AVD events */

/* COMMON events */

/* DSCL events */

/* HDMIRX events */
enum v4l2_ext_hdmi_event_id {
	V4L2_SRCCAP_CTRL_EVENT_HDMIRX_PKT_STATUS,
	V4L2_SRCCAP_CTRL_EVENT_HDMIRX_CABLE_DETECT,
	V4L2_SRCCAP_CTRL_EVENT_HDMIRX_HDCP2X_STATUS,
	V4L2_SRCCAP_CTRL_EVENT_HDMIRX_HDCP1X_STATUS,
	V4L2_SRCCAP_CTRL_EVENT_HDMIRX_HDMI_CRC,
	V4L2_SRCCAP_CTRL_EVENT_HDMIRX_HDMI_MODE,
	V4L2_SRCCAP_CTRL_EVENT_HDMIRX_HDCP_STATE,
	V4L2_SRCCAP_CTRL_EVENT_HDMIRX_DSC_STATE,
	V4L2_SRCCAP_CTRL_EVENT_HDMIRX_VTEM_VRR_EN_CHG,
	V4L2_SRCCAP_CTRL_EVENT_HDMIRX_VTEM_M_CONST_CHG,
	V4L2_SRCCAP_CTRL_EVENT_HDMIRX_VTEM_QMS_EN_CHG,
	V4L2_SRCCAP_CTRL_EVENT_HDMIRX_VTEM_FVA_FACTOR_M1_CHG,
	V4L2_SRCCAP_CTRL_EVENT_HDMIRX_VTEM_NEXT_TFR_CHG,
	V4L2_SRCCAP_CTRL_EVENT_HDMIRX_HDMI_MAX,
};

/* MEMOUT events */

/* MUX events */

/* TIMINGDETECT events */
#define V4L2_EVENT_SIGNAL_STATUS_CHANGE		(SRCCAP_TIMINGDETECT_EVENT_START | 0x0)
#define V4L2_EVENT_RESOLUTION_CHANGE		(SRCCAP_TIMINGDETECT_EVENT_START | 0x1)
#define V4L2_EVENT_FRAMERATE_CHANGE		(SRCCAP_TIMINGDETECT_EVENT_START | 0x2)
#define V4L2_EVENT_SCANTYPE_CHANGE		(SRCCAP_TIMINGDETECT_EVENT_START | 0x3)
#define V4L2_EVENT_COLORFORMAT_CHANGE		(SRCCAP_TIMINGDETECT_EVENT_START | 0x4)

#define V4L2_EVENT_HDMI_SIGNAL_CHANGE		(SRCCAP_TIMINGDETECT_EVENT_START | 0x10)
#define V4L2_EVENT_HDMI2_SIGNAL_CHANGE		(SRCCAP_TIMINGDETECT_EVENT_START | 0x11)
#define V4L2_EVENT_HDMI3_SIGNAL_CHANGE		(SRCCAP_TIMINGDETECT_EVENT_START | 0x12)
#define V4L2_EVENT_HDMI4_SIGNAL_CHANGE		(SRCCAP_TIMINGDETECT_EVENT_START | 0x13)

#define V4L2_EVENT_CVBS_SIGNAL_CHANGE		(SRCCAP_TIMINGDETECT_EVENT_START | 0x20)
#define V4L2_EVENT_CVBS2_SIGNAL_CHANGE		(SRCCAP_TIMINGDETECT_EVENT_START | 0x21)
#define V4L2_EVENT_CVBS3_SIGNAL_CHANGE		(SRCCAP_TIMINGDETECT_EVENT_START | 0x22)
#define V4L2_EVENT_CVBS4_SIGNAL_CHANGE		(SRCCAP_TIMINGDETECT_EVENT_START | 0x23)
#define V4L2_EVENT_CVBS5_SIGNAL_CHANGE		(SRCCAP_TIMINGDETECT_EVENT_START | 0x24)
#define V4L2_EVENT_CVBS6_SIGNAL_CHANGE		(SRCCAP_TIMINGDETECT_EVENT_START | 0x25)
#define V4L2_EVENT_CVBS7_SIGNAL_CHANGE		(SRCCAP_TIMINGDETECT_EVENT_START | 0x26)
#define V4L2_EVENT_CVBS8_SIGNAL_CHANGE		(SRCCAP_TIMINGDETECT_EVENT_START | 0x27)

#define V4L2_EVENT_SVIDEO_SIGNAL_CHANGE		(SRCCAP_TIMINGDETECT_EVENT_START | 0x30)
#define V4L2_EVENT_SVIDEO2_SIGNAL_CHANGE	(SRCCAP_TIMINGDETECT_EVENT_START | 0x31)
#define V4L2_EVENT_SVIDEO3_SIGNAL_CHANGE	(SRCCAP_TIMINGDETECT_EVENT_START | 0x32)
#define V4L2_EVENT_SVIDEO4_SIGNAL_CHANGE	(SRCCAP_TIMINGDETECT_EVENT_START | 0x33)

#define V4L2_EVENT_YPBPR_SIGNAL_CHANGE		(SRCCAP_TIMINGDETECT_EVENT_START | 0x40)
#define V4L2_EVENT_YPBPR2_SIGNAL_CHANGE		(SRCCAP_TIMINGDETECT_EVENT_START | 0x41)
#define V4L2_EVENT_YPBPR3_SIGNAL_CHANGE		(SRCCAP_TIMINGDETECT_EVENT_START | 0x42)

#define V4L2_EVENT_VGA_SIGNAL_CHANGE		(SRCCAP_TIMINGDETECT_EVENT_START | 0x50)
#define V4L2_EVENT_VGA2_SIGNAL_CHANGE		(SRCCAP_TIMINGDETECT_EVENT_START | 0x51)
#define V4L2_EVENT_VGA3_SIGNAL_CHANGE		(SRCCAP_TIMINGDETECT_EVENT_START | 0x52)

#define V4L2_EVENT_SCART_SIGNAL_CHANGE		(SRCCAP_TIMINGDETECT_EVENT_START | 0x60)
#define V4L2_EVENT_SCART2_SIGNAL_CHANGE		(SRCCAP_TIMINGDETECT_EVENT_START | 0x61)

/* VBI events */
#define V4L2_VBI_VPS_DATA_LENGTH 16

/* ============================================================================================== */
/* ------------------------------------------- Enums -------------------------------------------- */
/* ============================================================================================== */
enum v4l2_ext_hdmi_inputport_type {
	V4L2_EXT_HDMI_INPUT_PORT_NONE_PORT = 0,
	V4L2_EXT_HDMI_INPUT_PORT_0 = 80,
	V4L2_EXT_HDMI_INPUT_PORT_1,
	V4L2_EXT_HDMI_INPUT_PORT_2,
	V4L2_EXT_HDMI_INPUT_PORT_3,
	V4L2_EXT_HDMI_INPUT_PORT_MAX,
};

enum v4l2_ext_hdmi_eq_type {
	V4L2_EXT_HDMI_EQ_2M,	///< HDMI EQ 2M
	V4L2_EXT_HDMI_EQ_10M,	///< HDMI EQ 10M
	V4L2_EXT_HDMI_EQ_15M,	///< HDMI EQ 15M
	V4L2_EXT_HDMI_EQ_MAX,	///< HDMI EQ MAX
	V4L2_EXT_HDMI_EQ_USER_DEFINE,	///< HDMI EQ User define
};

enum v4l2_ext_hdmi_gccontrol_info_type {
	V4L2_EXT_HDMI_CTRL_AVMUTE = 0,	///< bit[0]: AVMUTE
	V4L2_EXT_HDMI_CTRL_DEFAULT_PHASE,	///< bit[1]: Default_Phase
	V4L2_EXT_HDMI_CTRL_LAST_PP,	///< bit[4:2]: LAST_PP[2:0]
	V4L2_EXT_HDMI_CTRL_PRE_LPP,	///< bit[7:5]: PRE_LPP[2:0]
	V4L2_EXT_HDMI_CTRL_CD_VAL,	///< bit[11:8]: CD_VAL[3:0]
	V4L2_EXT_HDMI_CTRL_PP_VAL,	///< bit[15:12]: PP_VAL[3:0]
	V4L2_EXT_HDMI_CTRL_ALL,
};

enum v4l2_ext_hdmi_reset_type {
	V4L2_EXT_HDMI_REST_AVMUTE = _BIT(8),	///<HDMI Reset bit[8]
	V4L2_EXT_HDMI_REST_Y_COLOR = _BIT(9),	///<HDMI Reset bit[9]
	V4L2_EXT_HDMI_REST_PIXEL_REPETITION  = _BIT(10),
						///<HDMI Reset bit[10]
	V4L2_EXT_HDMI_REST_FRAME_REPETITION  = _BIT(11),
						///<HDMI Reset bit[11]
	V4L2_EXT_HDMI_REST_GCP_PKT  = _BIT(12),	///<HDMI Reset bit[12]
	V4L2_EXT_HDMI_REST_DEEP_COLOR_FIFO  = _BIT(13),
						///<HDMI Reset bit[13]
	V4L2_EXT_HDMI_REST_RESERVE = _BIT(14),	///<HDMI Reset bit[14]
	V4L2_EXT_HDMI_REST_HDMI_STATUS = _BIT(15),
						///<HDMI Reset bit[15]
};

enum v4l2_ext_hdmi_channel_type {
	V4L2_EXT_HDMI_CHANNEL_R,
	V4L2_EXT_HDMI_CHANNEL_G,
	V4L2_EXT_HDMI_CHANNEL_B,
};

enum v4l2_ext_hdmi_source_version {
	V4L2_EXT_HDMI_SOURCE_VERSION_NOT_SURE,
	V4L2_EXT_HDMI_SOURCE_VERSION_14,
	V4L2_EXT_HDMI_SOURCE_VERSION_20,
	V4L2_EXT_HDMI_SOURCE_VERSION_21,
};

enum v4l2_ext_hdmi_avi_version {
	V4L2_EXT_HDMI_AVI_INFOFRAME_VERSION_NON,	//invalid version
	V4L2_EXT_HDMI_AVI_AVI_INFOFRAME_VERSION1,
					//AVI information frame version 1
	V4L2_EXT_HDMI_AVI_AVI_INFOFRAME_VERSION2,
					//AVI information frame version 2
	V4L2_EXT_HDMI_AVI_AVI_INFOFRAME_VERSION3
					//AVI information frame version 3
};

enum v4l2_ext_hdmi_additional_video_format {
	V4L2_EXT_HDMI_NO_ADDITIONAL_FORMAT, // 000
	V4L2_EXT_HDMI_4Kx2K_FORMAT,		 // 001
	V4L2_EXT_HDMI_3D_FORMAT,			// 010
	V4L2_EXT_HDMI_RESERVED,			 // 011 ~ 111
	V4L2_EXT_HDMI_NA					// Not available
};

enum v4l2_ext_hdmi_3d_input_mode {
	//range [0000 ~ 1111] reserved for hdmi 3D spec
	V4L2_EXT_HDMI_3D_INPUT_FRAME_PACKING			= 0x00, //0000
	V4L2_EXT_HDMI_3D_INPUT_FIELD_ALTERNATIVE		= 0x01, //0001
	V4L2_EXT_HDMI_3D_INPUT_LINE_ALTERNATIVE			= 0x02, //0010
	V4L2_EXT_HDMI_3D_INPUT_SIDE_BY_SIDE_FULL		= 0x03, //0011
	V4L2_EXT_HDMI_3D_INPUT_L_DEPTH				= 0x04, //0100
	V4L2_EXT_HDMI_3D_INPUT_L_DEPTH_GRAPHICS_GRAPHICS_DEPTH  = 0x05, //0101
	V4L2_EXT_HDMI_3D_INPUT_TOP_BOTTOM			= 0x06, //0110
	V4L2_EXT_HDMI_3D_INPUT_SIDE_BY_SIDE_HALF		= 0x08, //1000
	V4L2_EXT_HDMI_3D_INPUT_CHECK_BOARD			= 0x09, //1001
	//user defined
	V4L2_EXT_HDMI_3D_INPUT_MODE_USER			= 0x10,
	V4L2_EXT_HDMI_3D_INPUT_MODE_NONE = V4L2_EXT_HDMI_3D_INPUT_MODE_USER,
	V4L2_EXT_HDMI_3D_INPUT_FRAME_ALTERNATIVE,
	V4L2_EXT_HDMI_3D_INPUT_SIDE_BY_SIDE_HALF_INTERLACE,
	// optimize for format: in: V4L2_EXT_HDMI_3D_INPUT_FRAME_PACKING,
	// out: V4L2_EXT_HDMI_3D_OUTPUT_TOP_BOTTOM,
	// E_XC_3D_OUTPUT_SIDE_BY_SIDE_HALF
	V4L2_EXT_HDMI_3D_INPUT_FRAME_PACKING_OPT,
	// optimize for format: in: V4L2_EXT_HDMI_3D_INPUT_TOP_BOTTOM,
	//out: V4L2_EXT_HDMI_3D_OUTPUT_SIDE_BY_SIDE_HALF
	V4L2_EXT_HDMI_3D_INPUT_TOP_BOTTOM_OPT,
	V4L2_EXT_HDMI_3D_INPUT_NORMAL_2D,
	V4L2_EXT_HDMI_3D_INPUT_NORMAL_2D_INTERLACE,
	V4L2_EXT_HDMI_3D_INPUT_NORMAL_2D_INTERLACE_PTP,
	V4L2_EXT_HDMI_3D_INPUT_SIDE_BY_SIDE_HALF_INTERLACE_OPT,
	V4L2_EXT_HDMI_3D_INPUT_NORMAL_2D_HW,  //for hw 2D to 3D use
	V4L2_EXT_HDMI_3D_INPUT_PIXEL_ALTERNATIVE,
};

enum v4l2_ext_hdmi_3d_ext_data {
	V4L2_EXT_HDMI_3D_EXT_DATA_HOR_SUB_SAMPL_0,	  //0000
	V4L2_EXT_HDMI_3D_EXT_DATA_HOR_SUB_SAMPL_1,	  //0001
	V4L2_EXT_HDMI_3D_EXT_DATA_HOR_SUB_SAMPL_2,	  //0010
	V4L2_EXT_HDMI_3D_EXT_DATA_HOR_SUB_SAMPL_3,	  //0011
	V4L2_EXT_HDMI_3D_EXT_DATA_QUINCUNX_MATRIX_0,	//0100
	V4L2_EXT_HDMI_3D_EXT_DATA_QUINCUNX_MATRIX_1,	//0101
	V4L2_EXT_HDMI_3D_EXT_DATA_QUINCUNX_MATRIX_2,	//0110
	V4L2_EXT_HDMI_3D_EXT_DATA_QUINCUNX_MATRIX_3,	//0111
	V4L2_EXT_HDMI_3D_EXT_DATA_RESERVE,		//1000 ~ 1111
	V4L2_EXT_HDMI_3D_EXT_DATA_MODE_MAX,
};

enum v4l2_ext_hdmi_3d_meta_data_type {
	V4L2_EXT_HDMI_3D_META_DATA_PARALLAX_ISO23002_3,	  //0000
	V4L2_EXT_HDMI_3D_META_DATA_RESERVE,		//001 ~ 1111
	V4L2_EXT_HDMI_3D_META_DATA_MAX,
};

enum v4l2_ext_hdmi_emp_type {
	V4L2_EXT_HDMI_EMP_DOLBY_HDR,
	V4L2_EXT_HDMI_EMP_DSC,
	V4L2_EXT_HDMI_EMP_DYNAMIC_HDR,
	V4L2_EXT_HDMI_EMP_VRR,
	V4L2_EXT_HDMI_EMP_QFT,
	V4L2_EXT_HDMI_EMP_QMS,
	//MAX
	V4L2_EXT_HDMI_EMP_MAX
};

enum v4l2_ext_hdmi_hdcp_state {
	V4L2_EXT_HDMI_HDCP_NO_ENCRYPTION = 0, //0x00
	V4L2_EXT_HDMI_HDCP_1_4,			   //0x01
	V4L2_EXT_HDMI_HDCP_2_2,			   //0x02
};

enum v4l2_ext_hdmi_get_tmds_rates {
	V4L2_EXT_HDMI_GET_TMDS_BIT_RATES,
	V4L2_EXT_HDMI_GET_TMDS_CHARACTER_RATES,
	V4L2_EXT_HDMI_GET_TMDS_CLOCK_RATES,
	V4L2_EXT_HDMI_GET_PIXEL_CLOCK_RATES,
};

enum v4l2_ext_hdmi_packet_state {
	V4L2_EXT_HDMI_PKT_MPEG  = _BIT(0),	///< Pactet[0]
	V4L2_EXT_HDMI_PKT_AUI  = _BIT(1),	///< Pactet[1]
	V4L2_EXT_HDMI_PKT_SPD  = _BIT(2),	///< Pactet[2]
	V4L2_EXT_HDMI_PKT_AVI  = _BIT(3),	///< Pactet[3]
	V4L2_EXT_HDMI_PKT_GC  = _BIT(4),	///< Pactet[4]
	V4L2_EXT_HDMI_PKT_ASAMPLE  = _BIT(5),	///< Pactet[5]
	V4L2_EXT_HDMI_PKT_ACR  = _BIT(6),	///< Pactet[6]
	V4L2_EXT_HDMI_PKT_VS  = _BIT(7),	///< Pactet[7]
	V4L2_EXT_HDMI_PKT_NULL  = _BIT(8),	///< Pactet[8]
	V4L2_EXT_HDMI_PKT_ISRC2  = _BIT(9),	///< Pactet[9]
	V4L2_EXT_HDMI_PKT_ISRC1  = _BIT(10),	///< Pactet[10]
	V4L2_EXT_HDMI_PKT_ACP  = _BIT(11),	///< Pactet[11]
	V4L2_EXT_HDMI_PKT_ONEBIT_AUD  = _BIT(12),	///< Pactet[12]
	V4L2_EXT_HDMI_PKT_GM =  _BIT(13),	///< Pactet[13]
	V4L2_EXT_HDMI_PKT_HBR =  _BIT(14),	///< Pactet[14]
	V4L2_EXT_HDMI_PKT_VBI =  _BIT(15),	///< Pactet[15]
	V4L2_EXT_HDMI_PKT_HDR  = _BIT(16),	///< Pactet[16]
	V4L2_EXT_HDMI_PKT_RSV  = _BIT(17),	///< Pactet[17]
	V4L2_EXT_HDMI_PKT_EDR  = _BIT(18),	///< Pactet[18]
	V4L2_EXT_HDMI_PKT_CHANNEL_STATUS = _BIT(19),
	V4L2_EXT_HDMI_PKT_MULTI_VS = _BIT(20),
	V4L2_EXT_HDMI_PKT_EMP_VENDOR = _BIT(21),
	V4L2_EXT_HDMI_PKT_EMP_VTEM = _BIT(22),
	V4L2_EXT_HDMI_PKT_EMP_DSC = _BIT(23),
	V4L2_EXT_HDMI_PKT_EMP_HDR = _BIT(24),
};

enum v4l2_ext_hdmi_dsc_state {
	V4L2_EXT_HDMI_DSC_PKT_RECV_STATE_CHG = 0,
	V4L2_EXT_HDMI_DSC_SINGLE_PKT_RECV,
};

enum v4l2_ext_hdmi_color_format {
	V4L2_EXT_HDMI_COLOR_RGB,	///< HDMI RGB 444 Color Format
	V4L2_EXT_HDMI_COLOR_YUV_422,	///< HDMI YUV 422 Color Format
	V4L2_EXT_HDMI_COLOR_YUV_444,	///< HDMI YUV 444 Color Format
	V4L2_EXT_HDMI_COLOR_YUV_420,	///< HDMI YUV 420 Color Format
	V4L2_EXT_HDMI_COLOR_RESERVED,	///< Reserve
	V4L2_EXT_HDMI_COLOR_DEFAULT = V4L2_EXT_HDMI_COLOR_RGB,
						///< Default setting
	V4L2_EXT_HDMI_COLOR_UNKNOWN = 7,	///< Unknown Color Format
};

enum v4l2_ext_hdmi_color_range {
	V4L2_EXT_HDMI_COLOR_RANGE_DEFAULT, //
	V4L2_EXT_HDMI_COLOR_RANGE_LIMIT,   //HDMI RGB Limited Range (16-235)
	V4L2_EXT_HDMI_COLOR_RANGE_FULL,	//HDMI Full Range (0-255)
	V4L2_EXT_HDMI_COLOR_RANGE_RESERVED
};

enum v4l2_ext_hdmi_ext_colorimetry_format {
	V4L2_EXT_HDMI_EXT_COLOR_XVYCC601,		///< xvycc 601
	V4L2_EXT_HDMI_EXT_COLOR_XVYCC709,		///< xvycc 709
	V4L2_EXT_HDMI__EXT_COLOR_SYCC601,		 ///< sYCC 601
	V4L2_EXT_HDMI_EXT_COLOR_ADOBEYCC601,		///< Adobe YCC 601
	V4L2_EXT_HDMI_EXT_COLOR_ADOBERGB,		///< Adobe RGB
	V4L2_EXT_HDMI_EXT_COLOR_BT2020YcCbcCrc,  /// ITU-F BT.2020 YcCbcCrc
	V4L2_EXT_HDMI_EXT_COLOR_BT2020RGBYCbCr,  /// ITU-R BT.2020 RGB or YCbCr
	V4L2_EXT_HDMI_EXT_COLOR_ADDITIONAL_DCI_P3_RGB_D65,
	V4L2_EXT_HDMI_EXT_COLOR_ADDITIONAL_DCI_P3_RGB_THEATER,
	V4L2_EXT_HDMI_EXT_COLOR_DEFAULT = V4L2_EXT_HDMI_EXT_COLOR_XVYCC601,
							///< Default setting
	V4L2_EXT_HDMI_EXT_COLOR_UNKNOWN = 9,		///< Unknown
};

enum v4l2_ext_hdmi_pixel_repetition {
	V4L2_EXT_HDMI_PIXEL_REPETITION_1X = 0,
	V4L2_EXT_HDMI_PIXEL_REPETITION_2X,
	V4L2_EXT_HDMI_PIXEL_REPETITION_3X,
	V4L2_EXT_HDMI_PIXEL_REPETITION_4X,
	V4L2_EXT_HDMI_PIXEL_REPETITION_5X,
	V4L2_EXT_HDMI_PIXEL_REPETITION_6X,
	V4L2_EXT_HDMI_PIXEL_REPETITION_7X,
	V4L2_EXT_HDMI_PIXEL_REPETITION_8X,
	V4L2_EXT_HDMI_PIXEL_REPETITION_9X,
	V4L2_EXT_HDMI_PIXEL_REPETITION_10X,
	V4L2_EXT_HDMI_PIXEL_REPETITION_RESERVED,
};

enum v4l2_ext_hdmi_ar_type {
	// Active Format Aspect Ratio - AFAR
	//V4L2_EXT_HDMI_AF_AR_Not_Present   = -1,
	///< IF0[11..8] AFD not present, or AFD not yet found
	V4L2_EXT_HDMI_AF_AR_Reserve_0  = 0x00, ///< IF0[11..8] 0000, Reserved
	V4L2_EXT_HDMI_AF_AR_Reserve_1  = 0x01, ///< IF0[11..8] 0001, Reserved
	V4L2_EXT_HDMI_AF_AR_16x9_Top = 0x02,
					///< IF0[11..8] 0010, box 16:9 (top).
	V4L2_EXT_HDMI_AF_AR_14x9_Top = 0x03,
					///< IF0[11..8] 0011, box 14:9 (top).
	V4L2_EXT_HDMI_AF_AR_GT_16x9 = 0x04,
				///< IF0[11..8] 0100, box >16:9 (centre)
	V4L2_EXT_HDMI_AF_AR_Reserve_5  = 0x05,	///< IF0[11..8] 0101, Reserved
	V4L2_EXT_HDMI_AF_AR_Reserve_6  = 0x06,	///< IF0[11..8] 0110, Reserved
	V4L2_EXT_HDMI_AF_AR_Reserve_7  = 0x07,	///< IF0[11..8] 0111, Reserved
	V4L2_EXT_HDMI_AF_AR_SAME   = 0x08,
					///< IF0[11..8] 1000, same as picture
	V4L2_EXT_HDMI_AF_AR_4x3_C  = 0x09,
					///< IF0[11..8] 1001, 4:3 Center
	V4L2_EXT_HDMI__AF_AR_16x9_C = 0x0A,
					///< IF0[11..8] 1010, 16:9 Center
	V4L2_EXT_HDMI_AF_AR_14x9_C = 0x0B,
					///< IF0[11..8] 1011, 14:9 Center
	V4L2_EXT_HDMI_AF_AR_Reserve_12   = 0x0C,
						///< IF0[11..8] 1100, Reserved.
	V4L2_EXT_HDMI_AF_AR_4x3_with_14x9_C  = 0x0D,
		///< IF0[11..8] 1101, 4:3 with shoot and protect 14:9 centre.
	V4L2_EXT_HDMI_AF_AR_16x9_with_14x9_C = 0x0E,
		///< IF0[11..8] 1110, 16:9 with shoot and protect 14:9 centre.
	V4L2_EXT_HDMI_AF_AR_16x9_with_4x3_C = 0x0F,
		///< IF0[11..8] 1111, 16:9 with shoot and protect 4:3 centre.
	// Picture Aspect Ratio - PAR
	V4L2_EXT_HDMI_Pic_AR_NODATA = 0x00,	 ///< IF0[13..12] 00
	V4L2_EXT_HDMI_Pic_AR_4x3	= 0x10,	 ///< IF0[13..12] 01, 4:3
	V4L2_EXT_HDMI_Pic_AR_16x9   = 0x20,	 ///< IF0[13..12] 10, 16:9
	V4L2_EXT_HDMI_Pic_AR_RSV	= 0x30,	 ///< IF0[13..12] 11, reserved
};

enum v4l2_ext_hdmi_vic_4k2k_code {
	V4L2_EXT_HDMI_VIC_4Kx2K_30Hz = 0x01, // 1920(x2)x1080(x2) @ 29.97/30Hz
	V4L2_EXT_HDMI_VIC_4Kx2K_25Hz = 0x02, // 1920(x2)x1080(x2) @ 25Hz
	V4L2_EXT_HDMI_VIC_4Kx2K_24Hz = 0x03, // 1920(x2)x1080(x2) @ 23.976/24Hz
	V4L2_EXT_HDMI_VIC_4Kx2K_24Hz_SMPTE = 0x04, // 2048(x2)x1080(x2) @ 24Hz
	V4L2_EXT_HDMI_VIC_RESERVED,			// 0x00, 0x05 ~ 0xFF
	V4L2_EXT_HDMI_VIC_NA				// Not available
};

enum v4l2_ext_hdmi_color_depth {
	V4L2_EXT_HDMI_COLOR_DEPTH_6_BIT = 0,
	V4L2_EXT_HDMI_COLOR_DEPTH_8_BIT = 1,
	V4L2_EXT_HDMI_COLOR_DEPTH_10_BIT = 2,
	V4L2_EXT_HDMI_COLOR_DEPTH_12_BIT = 3,
	V4L2_EXT_HDMI_COLOR_DEPTH_16_BIT = 4,
	V4L2_EXT_HDMI_COLOR_DEPTH_UNKNOWN = 5,
};

enum v4l2_ext_hdmi_get_data_info {
	V4L2_EXT_HDMI_GET_HDE,
	V4L2_EXT_HDMI_GET_VDE,
	V4L2_EXT_HDMI_GET_HTT,
	V4L2_EXT_HDMI_GET_VTT,
	V4L2_EXT_HDMI_GET_AUDIO_PROTECT_INFO,
	V4L2_EXT_HDMI_GET_SUPPORT_EDID_SIZE,
	V4L2_EXT_HDMI_GET_ERROR_STATUS,
	V4L2_EXT_HDMI_GET_MULTIVS_COUNT,
	V4L2_EXT_HDMI_GET_ISRC1_HEADER_INFO,
};

enum v4l2_ext_hdmi_dither_type {
	V4L2_EXT_HDMI_NO_DITHER,
	V4L2_EXT_HDMI_1BIT_DITHER,
	V4L2_EXT_HDMI_2BIT_DITHER,
};

enum v4l2_ext_hdmi_dsc_decoder_mux_n {
	V4L2_EXT_HDMI_DSC_D0,
	V4L2_EXT_HDMI_DSC_D1,
	V4L2_EXT_HDMI_DSC_D2,
	V4L2_EXT_HDMI_DSC_D3,
	V4L2_EXT_HDMI_DSC_MAX,
};

/// HDMI Content Type
enum v4l2_ext_hdmi_content_type {
	V4L2_EXT_HDMI_CONTENT_NoData = 0,	// No Data.
	V4L2_EXT_HDMI_CONTENT_Graphics,  // Graphics(text).
	V4L2_EXT_HDMI_CONTENT_Photo,	 // Photo type.
	V4L2_EXT_HDMI_CONTENT_Cinema,	// Cinema type.
	V4L2_EXT_HDMI_CONTENT_Game,	  // Game type.
};

enum v4l2_srccap_input_source {
	V4L2_SRCCAP_INPUT_SOURCE_NONE = 0,
	V4L2_SRCCAP_INPUT_SOURCE_HDMI = 10,	/* 10   HDMI input */
	V4L2_SRCCAP_INPUT_SOURCE_HDMI2,		/* 11   HDMI2 input */
	V4L2_SRCCAP_INPUT_SOURCE_HDMI3,		/* 12   HDMI3 input */
	V4L2_SRCCAP_INPUT_SOURCE_HDMI4,		/* 13   HDMI4 input */
	V4L2_SRCCAP_INPUT_SOURCE_CVBS = 20,	/* 20   CVBS input */
	V4L2_SRCCAP_INPUT_SOURCE_CVBS2,		/* 21   CVBS2 input */
	V4L2_SRCCAP_INPUT_SOURCE_CVBS3,		/* 22   CVBS3 input */
	V4L2_SRCCAP_INPUT_SOURCE_CVBS4,		/* 23   CVBS4 input */
	V4L2_SRCCAP_INPUT_SOURCE_CVBS5,		/* 24   CVBS5 input */
	V4L2_SRCCAP_INPUT_SOURCE_CVBS6,		/* 25   CVBS6 input */
	V4L2_SRCCAP_INPUT_SOURCE_CVBS7,		/* 26   CVBS7 input */
	V4L2_SRCCAP_INPUT_SOURCE_CVBS8,		/* 27   CVBS8 input */
	V4L2_SRCCAP_INPUT_SOURCE_SVIDEO = 30,	/* 30   SVIDEO input */
	V4L2_SRCCAP_INPUT_SOURCE_SVIDEO2,	/* 31   SVIDEO2 input */
	V4L2_SRCCAP_INPUT_SOURCE_SVIDEO3,	/* 32   SVIDEO3 input */
	V4L2_SRCCAP_INPUT_SOURCE_SVIDEO4,	/* 33   SVIDEO4 input */
	V4L2_SRCCAP_INPUT_SOURCE_YPBPR = 40,	/* 40   YPBPR input */
	V4L2_SRCCAP_INPUT_SOURCE_YPBPR2,	/* 41   YPBPR2 input */
	V4L2_SRCCAP_INPUT_SOURCE_YPBPR3,	/* 42   YPBPR3 input */
	V4L2_SRCCAP_INPUT_SOURCE_VGA = 50,	/* 50   VGA input */
	V4L2_SRCCAP_INPUT_SOURCE_VGA2,		/* 51   VGA2 input */
	V4L2_SRCCAP_INPUT_SOURCE_VGA3,		/* 52   VGA3 input */
	V4L2_SRCCAP_INPUT_SOURCE_ATV = 60,	/* 60   ATV input */
	V4L2_SRCCAP_INPUT_SOURCE_SCART = 70,	/* 70   SCART input */
	V4L2_SRCCAP_INPUT_SOURCE_SCART2,	/* 71   SCART2 input */
	V4L2_SRCCAP_INPUT_SOURCE_DVI = 80,	/* 80   DVI input */
	V4L2_SRCCAP_INPUT_SOURCE_DVI2,		/* 81   DVI2 input */
	V4L2_SRCCAP_INPUT_SOURCE_DVI3,		/* 82   DVI3 input */
	V4L2_SRCCAP_INPUT_SOURCE_DVI4,		/* 83   DVI4 input */
	V4L2_SRCCAP_INPUT_SOURCE_NUM,
};

enum v4l2_ext_avd_videostandardtype {
	V4L2_EXT_AVD_STD_PAL_BGHI	= 0x00, // Video standard PAL BGHI
	V4L2_EXT_AVD_STD_NTSC_M	  = 0x01, // Video standard NTSC M
	V4L2_EXT_AVD_STD_SECAM	   = 0x02, // Video standard SECAM
	V4L2_EXT_AVD_STD_NTSC_44	 = 0x03, // Video standard NTSC 44
	V4L2_EXT_AVD_STD_PAL_M	   = 0x04, // Video standard PAL M
	V4L2_EXT_AVD_STD_PAL_N	   = 0x05, // Video standard PAL N
	V4L2_EXT_AVD_STD_PAL_60	  = 0x06, // Video standard PAL 60
	V4L2_EXT_AVD_STD_NOTSTANDARD = 0x07, // NOT Video standard
	V4L2_EXT_AVD_STD_AUTO		= 0x08, // Video standard AUTO
	V4L2_EXT_AVD_STD_MAX				 // Max Number
};

enum v4l2_ext_avd_Inputsourcetype {
	V4L2_EXT_AVD_SOURCE_INVVAILD = 0x00,  // Video source Invalid
	V4L2_EXT_AVD_SOURCE_ATV	  = 0x01,  // Video source ATV
	V4L2_EXT_AVD_SOURCE_CVBS1	= 0x02,  // Video source CVBS 1
	V4L2_EXT_AVD_SOURCE_CVBS2	= 0x03,  // Video source CVBS 2
	V4L2_EXT_AVD_SOURCE_CVBS3	= 0x04,  // Video source CVBS 2
	V4L2_EXT_AVD_SOURCE_SVIDEO1  = 0x05,  // Video source SVIDEO 1
	V4L2_EXT_AVD_SOURCE_SVIDEO2  = 0x06,  // Video source SVIDEO 2
	V4L2_EXT_AVD_SOURCE_SCART1   = 0x07,  // Video source SCART 1
	V4L2_EXT_AVD_SOURCE_SCAER2   = 0x08,  // Video source SCART 2
	V4L2_EXT_AVD_SOURCE_YPbPr	= 0x09,  // Video source YPbPr
	V4L2_EXT_AVD_SOURCE_MAX	  = 0x60   // Max Number
};

enum v4l2_ext_avd_load_code_type {
	V4L2_EXT_AVD_LOAD_CODE_BDMA_FROM_SPI,
	V4L2_EXT_AVD_LOAD_CODE_BDMA_FROM_DRAM,
	V4L2_EXT_AVD_LOAD_CODE_BYTE_WRITE,
};

enum v4l2_ext_avd_demod_type {
	V4L2_EXT_AVD_DEMODE_NORMAL		= 0,
	V4L2_EXT_AVD_DEMODE_MSTAR_VIF		= 1,
	V4L2_EXT_AVD_DEMODE_MSTAR_VIF_MSB1210	= 2,
};

enum v4l2_ext_avd_freerun_freq {
	V4L2_EXT_AVD_FREERUN_FQ_AUTO	= 0x00,
	V4L2_EXT_AVD_FREERUN_FQ_50Hz	= 0x01,
	V4L2_EXT_AVD_FREERUN_FQ_60Hz	= 0x02,
	V4L2_EXT_AVD_FREERUN_FQ_MAX
};

enum v4l2_ext_avd_factory_para {
	V4L2_EXT_AVD_FACTORY_PARA_AFEC_D4,
	V4L2_EXT_AVD_FACTORY_PARA_AFEC_D8,
	V4L2_EXT_AVD_FACTORY_PARA_AFEC_D5_BIT2,
	V4L2_EXT_AVD_FACTORY_PARA_AFEC_D9_BIT0,
	V4L2_EXT_AVD_FACTORY_PARA_AFEC_A0,
	V4L2_EXT_AVD_FACTORY_PARA_AFEC_A1,
	V4L2_EXT_AVD_FACTORY_PARA_AFEC_66_BIT67,
	V4L2_EXT_AVD_FACTORY_PARA_AFEC_6E_BIT7654,
	V4L2_EXT_AVD_FACTORY_PARA_AFEC_6E_BIT3210,
	V4L2_EXT_AVD_FACTORY_PARA_AFEC_43,
	V4L2_EXT_AVD_FACTORY_PARA_AFEC_44,
	V4L2_EXT_AVD_FACTORY_PARA_AFEC_CB,
	V4L2_EXT_AVD_FACTORY_PARA_AFEC_CF_BIT2,
	V4L2_EXT_AVD_FACTORY_PARA_AFEC_D5_BIT3,
	V4L2_EXT_AVD_FACTORY_PARA_AFEC_D7_HIGH,
	V4L2_EXT_AVD_FACTORY_PARA_AFEC_D7_LOW,
	V4L2_EXT_AVD_FACTORY_PARA_AFEC_MAX
};

enum v4l2_srccap_pcm_status {
	V4L2_SRCCAP_PCM_STABLE_NOSYNC = 0,
	V4L2_SRCCAP_PCM_STABLE_SYNC,
	V4L2_SRCCAP_PCM_UNSTABLE,
};

enum v4l2_ext_info_type {
	V4L2_EXT_INFO_TYPE_TIMING = 0,
	V4L2_EXT_INFO_TYPE_3D,
	V4L2_EXT_INFO_TYPE_WINDOW,
	V4L2_EXT_INFO_TYPE_ATV,
	V4L2_EXT_INFO_TYPE_DTV,
	V4L2_EXT_INFO_TYPE_HDMI,
	V4L2_EXT_INFO_TYPE_DVI,
	V4L2_EXT_INFO_TYPE_VGA,
	V4L2_EXT_INFO_TYPE_COMP,
	V4L2_EXT_INFO_TYPE_AV,
	V4L2_EXT_INFO_TYPE_SV,
	V4L2_EXT_INFO_TYPE_SCART,
	V4L2_EXT_INFO_TYPE_MM,
};

enum v4l2_memout_buf_ctrl_mode {
	V4L2_MEMOUT_SWMODE = 0,
	V4L2_MEMOUT_HWMODE,
	V4L2_MEMOUT_BYPASSMODE,
};

enum v4l2_timingdetect_status {
	V4L2_TIMINGDETECT_NO_SIGNAL = 0,
	V4L2_TIMINGDETECT_UNSTABLE_SYNC,
	V4L2_TIMINGDETECT_STABLE_SYNC,
};

typedef enum {
	V4L2_SRCCAP_VBI_TELETEXT,
	V4L2_SRCCAP_VBI_CC,
	V4L2_SRCCAP_VBI_WSS
} v4l2_srccap_vbi_init_type;

typedef enum {
	V4L2_SRCCAP_VBI_INIT,
	V4L2_SRCCAP_VBI_EXIT,
	V4L2_SRCCAP_VBI_SUSPEND,
	V4L2_SRCCAP_VBI_RESUME,
} v4l2_srccap_vbi_init_cmd;

typedef enum {
	V4L2_SRCCAP_VBI_VIDEO_SECAM,
	V4L2_SRCCAP_VBI_VIDEO_PAL_NC,
	V4L2_SRCCAP_VBI_VIDEO_PAL_M,
	V4L2_SRCCAP_VBI_VIDEO_NTSC,
	V4L2_SRCCAP_VBI_VIDEO_NTSC443_PAL60,
	V4L2_SRCCAP_VBI_VIDEO_PAL,
	V4L2_SRCCAP_VBI_VIDEO_OTHERS
} v4l2_srccap_vbi_standard;

enum v4l2_srccap_pq_domain_type {
	V4L2_SRCCAP_PQ_DOMAIN_INTPUT,
	V4L2_SRCCAP_PQ_DOMAIN_VD,
	V4L2_SRCCAP_PQ_DOMAIN_NUM,
};

enum v4l2_srccap_freesync_type {
	V4L2_SRCCAP_FREESYNC_SUPPORTED = _BIT(0),
	V4L2_SRCCAP_FREESYNC_ENABLED = _BIT(1),
	V4L2_SRCCAP_FREESYNC_ACTIVE = _BIT(2),
};

/* ============================================================================================== */
/* ------------------------------------------ Structs ------------------------------------------- */
/* ============================================================================================== */
struct v4l2_ext_hdmi_hdcp22_msg {
	__u8 ucPortIdx;
	union{
		__u64 addr1;
		__u8 *pucData;
	};
	__u32 dwDataLen;
	union{
		__u64 addr2;
		void *pDummy;
	};
} __attribute__((packed));

struct v4l2_ext_hdmi_enable {
	// port index from v4l2_srccap_input_source
	enum v4l2_srccap_input_source enInputPortType;
	// Enable or not
	bool bEnable;
} __attribute__((packed));

struct v4l2_ext_hdmi_eq {
	// HDMI Equalize Level
	enum v4l2_ext_hdmi_eq_type enEq;
	// HDMI Equalize value
	__u8 u8EQValue;
	// port index from v4l2_srccap_input_source
	enum v4l2_srccap_input_source enInputPortType;
} __attribute__((packed));

struct v4l2_ext_hdmi_hpd {
	// HPD high or low
	bool bHighLow;
	// port index from v4l2_srccap_input_source
	enum v4l2_srccap_input_source enInputPortType;
	// HPD should be inverse or not
	bool bInverse;
} __attribute__((packed));

struct v4l2_ext_hdmi_sw_reset {
	// port index from v4l2_srccap_input_source
	enum v4l2_srccap_input_source enInputPortType;
	// indicate which module to reset
	__u16 u16Reset;
} __attribute__((packed));

struct v4l2_ext_hdmi_pkt_reset {
	// port index from v4l2_srccap_input_source
	enum v4l2_srccap_input_source enInputPortType;
	// indicate which type of packet to reset
	enum v4l2_ext_hdmi_reset_type enResetType;
} __attribute__((packed));

struct v4l2_ext_hdmi_clkrterm_ctrl {
	// port index from v4l2_srccap_input_source
	enum v4l2_srccap_input_source enInputPortType;
	// pull clk low if it's true, else pull clock rterm high
	bool bPullLow;
} __attribute__((packed));

struct v4l2_ext_hdmi_hdcp_readdone {
	__u8 u8PortIdx;
	bool bReadFlag;
} __attribute__((packed));

struct v4l2_ext_hdmi_gc_info {
	// port index from v4l2_srccap_input_source
	enum v4l2_srccap_input_source enInputPortType;
	// Choose which GC field to get
	enum v4l2_ext_hdmi_gccontrol_info_type gcontrol;
	// get return GC field
	__u16 u16GCdata;
} __attribute__((packed));

struct v4l2_ext_hdmi_err_status {
	// port index from v4l2_srccap_input_source
	enum v4l2_srccap_input_source enInputPortType;
	// indicate which bit need to be clear
	__u8 u8value;
	// indicate read or not
	bool bread;
	// return read error status
	__u8 u8RetValue;
} __attribute__((packed));

struct v4l2_ext_hdmi_byte {
	// port index from v4l2_srccap_input_source
	enum v4l2_srccap_input_source enInputPortType;
	// return byte value
	__u8 u8RetValue;
} __attribute__((packed));

struct v4l2_ext_hdmi_word {
	// port index from v4l2_srccap_input_source
	enum v4l2_srccap_input_source enInputPortType;
	// return word value
	__u16 u16RetValue;
} __attribute__((packed));

struct v4l2_ext_hdmi_bool {
	// port index from v4l2_srccap_input_source
	enum v4l2_srccap_input_source enInputPortType;
	// return bool value
	bool bRet;
} __attribute__((packed));

struct v4l2_ext_hdmi_dither {
	// port index from v4l2_srccap_input_source
	enum v4l2_srccap_input_source enInputPortType;
	// dither type from  v4l2_ext_hdmi_dither_type
	enum v4l2_ext_hdmi_dither_type enDitherType;
	// rounding enable
	bool ubRoundEnable;
} __attribute__((packed));

struct v4l2_ext_hdmi_3d_meta_filed {
	bool b3D_Meta_Present;
	enum v4l2_ext_hdmi_3d_meta_data_type t3D_Metadata_Type;
	__u8 u83D_Metadata_Length;
	__u8 u83D_Metadata[23]; // Maximum length of VS is 31 - 8 = 23
} __attribute__((packed));

struct v4l2_ext_hdmi_meta_filed {
	// port index from v4l2_srccap_input_source
	enum v4l2_srccap_input_source enInputPortType;
	// return bool value
	struct v4l2_ext_hdmi_3d_meta_filed st3D_META_DATA;
} __attribute__((packed));

struct v4l2_ext_hdmi_crc_value {
	enum v4l2_srccap_input_source enInputPortType;
	enum v4l2_ext_hdmi_channel_type u8Channel;
	union{
		__u64 addr1;
		__u16 *u16CRCVal;
	};
	bool bIsValid;
} __attribute__((packed));

struct v4l2_ext_hdmi_emp_info {
	enum v4l2_srccap_input_source enInputPortType;
	enum v4l2_ext_hdmi_emp_type enEmpType;
	__u8 u8CurrentPacketIndex;
	union{
		__u64 addr1;
		__u8 *pu8TotalPacketNumber;
	};
	union{
		__u64 addr2;
		__u8 *pu8EmPacket;
	};
} __attribute__((packed));

struct v4l2_ext_hdmi_cmd_hdcp_state {
	enum v4l2_srccap_input_source enInputPortType;
	__u8 ucHDCPState;
} __attribute__((packed));

struct v4l2_ext_hdmi_cmd_hdcp_writex74 {
	enum v4l2_srccap_input_source enInputPortType;
	__u8 ucOffset;
	__u8 ucData;
} __attribute__((packed));

struct v4l2_ext_hdmi_cmd_hdcp_readx74 {
	enum v4l2_srccap_input_source enInputPortType;
	__u8 ucOffset;
	__u8 ucRetData;
} __attribute__((packed));

struct v4l2_ext_hdmi_cmd_hdcp_set_repeater {
	enum v4l2_srccap_input_source enInputPortType;
	bool bIsRepeater;
} __attribute__((packed));

struct v4l2_ext_hdmi_cmd_hdcp_set_bstatus {
	enum v4l2_srccap_input_source enInputPortType;
	__u16 usBstatus;
} __attribute__((packed));

struct v4l2_ext_hdmi_cmd_hdcp_set_hdmimode {
	// port Index v4l2_srccap_input_source
	enum v4l2_srccap_input_source enInputPortType;
	// set HDMI mode or not
	bool bHDMIMode;
} __attribute__((packed));

struct v4l2_ext_hdmi_cmd_hdcp_get_interrupt_status {
	// port Index v4l2_srccap_input_source
	enum v4l2_srccap_input_source enInputPortType;
	// return HDCP interrupt status
	__u8 ucRetIntStatus;
} __attribute__((packed));

struct v4l2_ext_hdmi_cmd_hdcp_write_ksvlist {
	// port Index v4l2_srccap_input_source
	enum v4l2_srccap_input_source enInputPortType;
	union{
		__u64 addr1;
		// KSV List data
		__u8 *pucKSV;
	};
	// KSV List Length
	__u32 ulLen;
} __attribute__((packed));

struct v4l2_ext_hdmi_cmd_hdcp_set_vprime {
	// port Index v4l2_srccap_input_source
	enum v4l2_srccap_input_source enInputPortType;
	union{
		__u64 addr1;
		// VPrime
		__u8 *pucVPrime;
	};
} __attribute__ ((packed));

struct v4l2_ext_hdmi_cmd_data_rterm_control {
	// port Index v4l2_srccap_input_source
	enum v4l2_srccap_input_source enInputPortType;
	// Enable Date Rterm
	bool bDataRtermEnable;
} __attribute__((packed));

struct v4l2_ext_hdmi_cmd_get_scdc_value {
	// port Index v4l2_srccap_input_source
	enum v4l2_srccap_input_source enInputPortType;
	// SCDC offset
	__u8 ucOffset;
	// return SCDC data
	__u8 ucRetData;
} __attribute__((packed));

struct v4l2_ext_hdmi_cmd_get_tmds_rate {
	// port Index v4l2_srccap_input_source
	enum v4l2_srccap_input_source enInputPortType;
	// Rate Type
	enum v4l2_ext_hdmi_get_tmds_rates enType;
	// return rate value
	__u32 ulRetRates;
} __attribute__((packed));

struct v4l2_ext_hdmi_cmd_get_cable_detect {
	// port Index v4l2_srccap_input_source
	enum v4l2_srccap_input_source enInputPortType;
	// return cable detect or not
	bool bCableDetectFlag;
} __attribute__((packed));

struct v4l2_ext_hdmi_extend_pkt_receive {
	// Version.
	__u16 u16Version;
	// Structure size.
	__u16 u16Size;
	//  MPEG packet received
	bool bPKT_MPEG_RECEIVE;
	// AUI packet received
	bool bPKT_AUI_RECEIVE;
	// SPD packet received
	bool bPKT_SPD_RECEIVE;
	// AVI packet received
	bool bPKT_AVI_RECEIVE;
	// GC packet received
	bool bPKT_GC_RECEIVE;
	// ASAMPLE packet received
	bool bPKT_ASAMPLE_RECEIVE;
	// ACR packet received
	bool bPKT_ACR_RECEIVE;
	// VS packet received
	bool bPKT_VS_RECEIVE;
	// NULL packet received
	bool bPKT_NULL_RECEIVE;
	// ISRC2 packet received
	bool bPKT_ISRC2_RECEIVE;
	// ISRC1 packet received
	bool bPKT_ISRC1_RECEIVE;
	// ACP packet received
	bool bPKT_ACP_RECEIVE;
	// ONE bit AUD packet received
	bool bPKT_ONEBIT_AUD_RECEIVE;
	// GM packet received
	bool bPKT_GM_RECEIVE;
	// HBR packet received
	bool bPKT_HBR_RECEIVE;
	// VBIpacket received
	bool bPKT_VBI_RECEIVE;
	// HDR packet received
	bool bPKT_HDR_RECEIVE;
	// RSV packet received
	bool bPKT_RSV_RECEIVE;
	// Dolby EDR packet valid
	bool bPKT_EDR_VALID;
	// DST
	bool bPKT_AUDIO_DST_RECEIVE;
	// 3D L-PCM
	bool bPKT_AUDIO_3D_ASP_RECEIVE;
	// One bit 3D audio
	bool bPKT_AUDIO_3D_DSD_RECEIVE;
	// Audio metadata
	bool bPKT_AUDIO_METADATA_RECEIVE;
	// Multi-stream
	bool bPKT_AUDIO_MULTI_ASP_RECEIVE;
	// Multi-stream one bit audio
	bool bPKT_AUDIO_MULTI_DSD_RECEIVE;
	// EM packet received
	bool bPKT_EM_RECEIVE;
	// EM vendor pkt
	bool bPKT_EM_VENDOR_RECEIVE;
	// EM VTEM pkt (vrr, fva)
	bool bPKT_EM_VTEM_RECEIVE;
	// EM DSC pkt (dsc pps info)
	bool bPKT_EM_DSC_RECEIVE;
	// EM HDR (dynamic  HDR)
	bool bPKT_EM_HDR_RECEIVE;
} __attribute__((packed));

struct v4l2_ext_hdmi_cmd_get_pkt_status {
	// port Index v4l2_srccap_input_source
	enum v4l2_srccap_input_source enInputPortType;
	union{
		__u64 addr1;
		// packet status
		struct v4l2_ext_hdmi_extend_pkt_receive *pExtendPacketReceive;
	};
} __attribute__((packed));

struct v4l2_ext_hdmi_cmd_get_pkt_content {
	// port Index v4l2_srccap_input_source
	enum v4l2_srccap_input_source enInputPortType;
	// packet type
	enum v4l2_ext_hdmi_packet_state enPacketType;
	// packet length
	__u8 u8PacketLength;
	union{
		__u64 addr1;
		// packet contetn
		__u8 *pu8PacketContent;
	};
} __attribute__((packed));

struct v4l2_ext_hdmi_hdr_metadata {
	// Version.
	__u16	  u16Version;
	// Structure size.
	__u16	  u16Size;
	//0:SDR gamma, 1:HDR gamma, 2:SMPTE ST2084, 3:Future EOTF, 4-7:Reserved
	__u8	   u8EOTF;
	// 0:Static Metadata Type 1,  1-7:Reserved for future use
	__u8	   u8Static_Metadata_ID;
	// display_primaries_x
	__u16	  u16Display_Primaries_X[3];
	// display_primaries_x
	__u16	  u16Display_Primaries_Y[3];
	// display primaries Wx
	__u16	  u16White_Point_X;
	// display primaries Wy
	__u16	  u16White_Point_Y;
	// max display mastering luminance
	__u16	  u16Max_Display_Mastering_Luminance;
	// min display mastering luminance
	__u16 u16Min_Display_Mastering_Luminance;
	// maximum content light level
	__u16	  u16Maximum_Content_Light_Level;
	// maximum frame-average light level
	__u16	  u16Maximum_Frame_Average_Light_Level;
	// packet content version
	__u8	   u8Version;
	// packet length
	__u8	   u8Length;
} __attribute__((packed));

struct v4l2_ext_hdmi_cmd_get_hdr_metadata {
	// port Index v4l2_srccap_input_source
	enum v4l2_srccap_input_source enInputPortType;
	union{
		__u64 addr1;
		// HDR Meta data
		struct v4l2_ext_hdmi_hdr_metadata *pstHDRMetadata;
	};
} __attribute__((packed));

struct v4l2_ext_hdmi_avi_parsing_info {
	// Version.
	__u16 u16StructVersion;
	// Structure size.
	__u16 u16StructSize;
	// AVI version
	__u8 u8Version;
	// AVI infoframe length
	__u8 u8Length;
	// AVI S1/0 value
	__u8 u8S10Value;
	// AVI B1/0 value
	__u8 u8B10Value;
	// AVI A0 value
	__u8 u8A0Value;
	// AVI Y2/1/0 value
	__u8 u8Y210Value;
	// AVI R3/2/1/0 value
	__u8 u8R3210Value;
	// AVI M1/0 value
	__u8 u8M10Value;
	// AVI C1/0 value
	__u8 u8C10Value;
	// AVI SC1/0 value
	__u8 u8SC10Value;
	// AVI Q1/0 value
	__u8 u8Q10Value;
	// AVI EC2/1/0 value
	__u8 u8EC210Value;
	// AVI IV/CV value
	__u8 u8ITCValue;
	// AVI VIC
	__u8 u8VICValue;
	// AVI PR3/2/1/0 value
	__u8 u8PR3210Value;
	// AVI CN1/0 value
	__u8 u8CN10Value;
	// AVI YQ1/0 value
	__u8 u8YQ10Value;
	// AVI ACE3/2/1/0 value
	__u8 u8ACE3210Value;
	// AVI color format
	enum v4l2_ext_hdmi_color_format enColorForamt;
	// AVI color range
	enum v4l2_ext_hdmi_color_range enColorRange;
	// AVI extend colorimetry
	enum v4l2_ext_hdmi_ext_colorimetry_format enColormetry;
	// AVI pixel repetition
	enum v4l2_ext_hdmi_pixel_repetition enPixelRepetition;
	// AVI aspect ratio
	enum v4l2_ext_hdmi_ar_type enAspectRatio;
	// AVI active format aspect ratio
	enum v4l2_ext_hdmi_ar_type enActiveFormatAspectRatio;
} __attribute__((packed));

struct v4l2_ext_hdmi_cmd_get_avi_parsing_info {
	// port Index v4l2_srccap_input_source
	enum v4l2_srccap_input_source enInputPortType;
	union{
		__u64 addr1;
		// AVI parsing information
		struct v4l2_ext_hdmi_avi_parsing_info *pstAVIParsingInfo;
	};
} __attribute__((packed));

struct v4l2_ext_hdmi_vs_parsing_info {
	// Structure Version.
	__u16 u16StructVersion;
	// Structure size.
	__u16 u16StructSize;
	// VS version
	__u8 u8Version;
	// VS length
	__u8 u8Length;
	// VS VIC
	__u8 u8HDMIVIC;
	// VS 3D structure
	__u8 u83DStructure;
	// VS 3D extended data
	__u8 u83DExtData;
	// VS video additional format
	enum v4l2_ext_hdmi_additional_video_format enHDMIVideoFormat;
	// VS 4k2k parsing VIC
	enum v4l2_ext_hdmi_vic_4k2k_code en4Kx2KVICCode;
	// VS 3D parsing structure
	enum v4l2_ext_hdmi_3d_input_mode en3DStructure;
	// VS parsing extended structure
	enum v4l2_ext_hdmi_3d_ext_data en3DExtendedData;
	// VS MM mode
	__u8 u8ALLMMode;
} __attribute__((packed));

struct v4l2_ext_hdmi_cmd_get_vs_parsing_info {
	// port Index v4l2_srccap_input_source
	enum v4l2_srccap_input_source enInputPortType;
	union{
		__u64 addr1;
		// VS parsing information
		struct v4l2_ext_hdmi_vs_parsing_info *pstVSParsingInfo;
	};
} __attribute__((packed));

struct v4l2_ext_hdmi_gc_parsing_info {
	// Version
	__u16 u16StructVersion;	 // Version.
	// Structure Size
	__u16 u16StructSize;		// Structure size.
	// AVMute
	__u8 u8ControlAVMute;
	// VS byte0 bit0
	__u8 u8DefaultPhase;
	// color depth
	__u8 u8CDValue;
	// deep color phase
	__u8 u8PPValue;
	// VS byte0 bit2~bit4
	__u8 u8LastPPValue;
	// VS byte0 bit5~bit7
	__u8 u8PreLastPPValue;
	// parsing color depth
	enum v4l2_ext_hdmi_color_depth enColorDepth;
} __attribute__((packed));

struct v4l2_ext_hdmi_cmd_get_gc_parsing_info {
	// port Index v4l2_srccap_input_source
	enum v4l2_srccap_input_source enInputPortType;
	union{
		__u64 addr1;
		// GC parsing information
		struct v4l2_ext_hdmi_gc_parsing_info *pstGCParsingInfo;
	};
} __attribute__ ((packed));

struct v4l2_ext_hdmi_cmd_get_timing_info {
	// port Index v4l2_srccap_input_source
	enum v4l2_srccap_input_source enInputPortType;
	// indicate which data info
	enum v4l2_ext_hdmi_get_data_info enInfoType;
	// return timing information
	__u16 u16TimingInfo;
} __attribute__((packed));

struct v4l2_ext_hdmi_cmd_hdcp_auth_state {
	// port Index v4l2_srccap_input_source
	enum v4l2_srccap_input_source enInputPortType;
	// HDCP version
	enum v4l2_ext_hdmi_hdcp_state enHDCPAuthVersion;
} __attribute__((packed));

struct v4l2_ext_hdmi_ctrl {
	// Command ID for further HDMIRx control function :
	// v4l2_ext_hdmi_ctrl_id
	__u32 u32Cmd;
	union{
		__u64 addr1;
		// pointer to struct v4l2_ext_hdmi_cmd_hdcp_state
		void *pBuf;
	};
	// size of stCMD_HDMI_CHECK_HDCP_STATE
	__u32 u32BufSize;
} __attribute__((packed));

struct v4l2_ext_hdmi_pkt {
	enum v4l2_srccap_input_source enInputPortType;
	enum v4l2_ext_hdmi_packet_state e_pkt_type;
	union{
		__u64 addr1;
		void *pBuf;
	};
	__u32 u32BufSize;
	__u8 u8Ret_n;
} __attribute__((packed));

struct v4l2_ext_hdmi_pkt_st_basic {
	__u8 u8hb[3];
	__u8 u8pb[28];
} __attribute__((packed));

struct v4l2_ext_hdmi_mux_ioctl_s {
	enum v4l2_srccap_input_source enInputPortType;
	enum v4l2_ext_hdmi_dsc_decoder_mux_n dsc_mux_n;
	__u32 u32_param[4];
	bool bRet;
	union{
		__u64 addr1;
		void *p_buf;
	};
} __attribute__((packed));

struct v4l2_ext_hdmi_dsc_info {
	// port index from v4l2_srccap_input_source
	enum v4l2_srccap_input_source enInputPortType;
	bool bRet;

	__u16 u8_bpc;	 // pps3[7:4]
	__u16 u8_linebuf_depth; // pps[3:0]
	__u16 u16_bpp; // bpp_real = u16_bpp >> 4  // pps4[1:0]<<8|pps5
	__u16 u16_pic_height;  // pps6<<8|pps7
	__u16 u16_pic_width;  // pps8<<8|pps9
	__u16 u16_slice_height; // pps10<<8|pps11
	__u16 u16_slice_width; // pps12<<8|pps13
	__u16 u16_chunkbytes; // pps14<<8|pps15
	__u16 u16_initial_dec_delay;  // pps18<<8|pps19
	__u8 u8_native_422;  // pps88[0]
	__u8 u8_native_420; // pps[1]
	__u16 u16_hfront; // pps129<<8|pps128
	__u16 u16_hsync; // pps131<<8|pps130
	__u16 u16_hback; // pps133<<8|pps132
	__u16 u16_hactivebytes; // pps135<<8|pps134
	__u8  u8_slice_num;
} __attribute__((__packed__));

struct v4l2_ext_hdmi_pkt_que_time_s {
	// min,avg,max
	__u32 u32_vsync_interval[3];
	__u32 u32_vsync_handler[3];
	__u8 u8_framecnt_interval[3];
} __attribute__((__packed__));

struct v4l2_ext_hdmi_pkt_report_s {
	struct v4l2_ext_hdmi_pkt_que_time_s time_info;
	__u16 u16_latency[4];
	__u32 u32_isr_cnt;
	__u16 u16_frame_cnt_chg_at_handler;
	__u16 u16_handler_late;
	__u16 u16_pkt_overwrite;
	__u16 u16_crc_mismatch;
} __attribute__((__packed__));

struct v4l2_ext_hdmi_sim_data {
	__u8 u8data[1024];
} __attribute__((packed));

struct v4l2_ext_hdmi_get_audio_sampling_freq {
	// port index from v4l2_srccap_input_source
	enum v4l2_srccap_input_source enInputPortType;
	// return dword value
	__u32 u32RetValue_hz;
} __attribute__((packed));

struct v4l2_ext_hdmi_set_pwr_saving_onoff {
	enum v4l2_srccap_input_source enInputPortType;
	bool b_on;
	bool bRet;
} __attribute__((packed));

struct v4l2_ext_hdmi_get_pwr_saving_onoff {
	enum v4l2_srccap_input_source enInputPortType;
	bool bRet_hwdef;
	bool bRet_swprog;
} __attribute__((packed));

struct v4l2_ext_hdmi_get_freesync_info {
	// port index from v4l2_srccap_input_source
	enum v4l2_srccap_input_source enInputPortType;
	__u8 u8_fsinfo;
	bool bRet;
} __attribute__((packed));

struct v4l2_timing {
	__u32 h_total;
	__u32 v_total;
	__u32 h_freq;  // multiply 1000
	__u32 v_freq; // multiply 1000
	__u32 de_x;
	__u32 de_y;
	__u32 de_width;
	__u32 de_height;
	__u8 interlance;
	__u8 sync_status; //bitwise value, reference v4l2_ext_sync_status
	__u32 h_period;
} __attribute__((packed));

struct v4l2_srccap_pqmap_rm_info {
	union {
		__u64 addr;
		__u16 *node_array;
	} p;
	__u16 array_size;
} __attribute__((packed));

struct v4l2_srccap_pqmap_info {
	bool bInited;
	bool bVdInited;
	bool bRuin;
	int pqmap_fd;
	__u32 u32PimLen;
	__u32 u32RmLen;
	enum v4l2_srccap_pq_domain_type eDomain_type;
} __attribute__((packed));

struct v4l2_ext_avd_standard_detection {
	unsigned short u16LatchStatus;
	v4l2_std_id u64VideoStandardType;
} __attribute__((__packed__));

struct v4l2_ext_avd_scan_hsyc_check {
	unsigned char u8HtotalTolerance;
	unsigned short u16ScanHsyncCheck;
} __attribute__((__packed__));

struct v4l2_ext_avd_info {
	enum v4l2_srccap_input_source einputsourcetype;
	v4l2_std_id u64VideoSystem;
	v4l2_std_id u64LastStandard;
	unsigned char u8AutoDetMode;
	unsigned short u16CurVDStatus;
	unsigned char u8AutoTuningIsProgress;
	struct v4l2_srccap_pqmap_rm_info stRminfo;
} __attribute__((packed));

struct v4l2_ext_avd_sync_sensitivity {
	unsigned char u8DetectWinBeforeLock;
	unsigned char u8DetectWinAfterLock;
	unsigned char u8CNTRFailBeforeLock;
	unsigned char u8CNTRSyncBeforeLock;
	unsigned char u8CNTRSyncAfterLock;
} __attribute__((__packed__));

struct v4l2_ext_avd_init_data {

	// register init
	unsigned char *u8VdDecInitializeExt; // TODO use system variable type
	#if !defined(__aarch64__)
	unsigned int u32AlignDummy;
	#endif

	unsigned int u32XTAL_Clock;
	enum v4l2_ext_avd_load_code_type eLoadCodeType;
	unsigned int u32VD_DSP_Code_Address;
	unsigned char *pu8VD_DSP_Code_Address;
	#if !defined(__aarch64__)
	unsigned int u32AlignDummy1;
	#endif
	unsigned int u32VD_DSP_Code_Len;
	// VIF related
	enum v4l2_ext_avd_demod_type eDemodType;

	// afec related
	unsigned short u16VDDSPBinID;
	unsigned char bRFGainSel;
	unsigned char bAVGainSel;
	unsigned char u8RFGain;
	unsigned char u8AVGain;
	unsigned int u32VDPatchFlag;
	unsigned char u8ColorKillHighBound;
	unsigned char u8ColorKillLowBound;
	unsigned char u8SwingThreshold;
	struct v4l2_ext_avd_sync_sensitivity eVDHsyncSensitivityNormal;
	struct v4l2_ext_avd_sync_sensitivity eVDHsyncSensitivityTuning;

	// comb related
	unsigned long long u32COMB_3D_ADR; //MS_PHY u32COMB_3D_ADR;
	unsigned int u32COMB_3D_LEN;

	//heap id
	unsigned int u32CMA_HEAP_ID;

} __attribute__((__packed__));

struct v4l2_ext_avd_init_para {
	#if !defined(__aarch64__)
	unsigned int u32AlignDummy1;
	#endif

	struct v4l2_ext_avd_init_data *pinit_data;

	#if !defined(__aarch64__)
	unsigned int u32AlignDummy2;
	#endif

	unsigned int u32InitDataLen;
} __attribute__((packed));

struct v4L2_ext_avd_video_standard {
	v4l2_std_id u64Videostandardtype;
	unsigned char bIsInAutoTuning;
} __attribute__((__packed__));

struct v4l2_ext_avd_still_image_param {
	unsigned char u8Threshold1;
	unsigned char u8Threshold2;
	unsigned char u8Threshold3;
	unsigned char u8Threshold4;

	unsigned char u8Str1_COMB37;
	unsigned char u8Str1_COMB38;
	unsigned char u8Str1_COMB7C;
	unsigned char u8Str1_COMBED;

	unsigned char u8Str2_COMB37;
	unsigned char u8Str2_COMB38;
	unsigned char u8Str2_COMB7C;
	unsigned char u8Str2_COMBED;

	unsigned char u8Str3_COMB37;
	unsigned char u8Str3_COMB38;
	unsigned char u8Str3_COMB7C;
	unsigned char u8Str3_COMBED;
	bool bMessageOn;
} __attribute__((__packed__));

struct v4l2_ext_avd_factory_data {
	enum v4l2_ext_avd_factory_para eFactoryPara;
	unsigned char u8Value;
} __attribute__((__packed__));

struct v4l2_ext_avd_3d_comb_speed {
	unsigned char u8COMB57;
	unsigned char u8COMB58;
} __attribute__((__packed__));

struct v4l2_ext_avd_set_input {
	enum v4l2_srccap_input_source eInputSource;
	__u8 u8ScartFB;
} __attribute__((__packed__));


struct v4l2_common_force_vsync {
	__u32 type;	//enum srccap_common_irq_type
	__u32 event;	//enum srccap_common_irq_event
	bool set_force;
} __attribute__((packed));

struct v4l2_adc_source {
	union {
		__u64 addr;
		enum v4l2_srccap_input_source *adc_input_src;
	} p;
	__u32 src_count;
} __attribute__((packed));

struct v4l2_adc_gain {
	__u16 r_gain;
	__u16 g_gain;
	__u16 b_gain;
} __attribute__((packed));

struct v4l2_adc_offset {
	__u16 r_offset;
	__u16 g_offset;
	__u16 b_offset;
} __attribute__((packed));

struct v4l2_area_size {
	__u32   width;
	__u32   height;
} __attribute__((packed));

struct v4l2_dscl_size {
	struct v4l2_area_size input;	///< input window size
	struct v4l2_area_size output;	///< output window size
} __attribute__((packed));

struct v4l2_dscl_info {
	struct v4l2_dscl_size dscl_size;
	struct v4l2_srccap_pqmap_rm_info rm_info;
} __attribute__((packed));

struct v4l2_memout_buf {
	int frame_fd;	///< frame fd
	int meta_fd;	///< metadata fd
} __attribute__((packed));

// Temp structure, must move to meta utility
struct v4l2_memout_md {
	__u8 AID;
	__u32 video_pipelineID;
} __attribute__((packed));

struct v4l2_memout_secure_info {
	bool bEnable;		///< secure mode flag
	bool bForceSVP;		///< force svp flag
} __attribute__((packed));

struct v4l2_memout_sst_info {
	bool HDMI1_secure;
	bool HDMI2_secure;
	bool HDMI3_secure;
	bool HDMI4_secure;
} __attribute__((packed));

struct v4l2_timingdetect_timing {
	__u32 vfreqx1000; // unit: Hz
	__u16 hstart;
	__u16 vstart;
	__u16 hde;
	__u16 vde;
	__u16 htt;
	__u16 vtt;
	__u16 adcphase;
	bool interlaced;
	bool ce_timing;
} __attribute__((packed));

struct v4l2_memout_timeval {
	__u64 tv_sec;
	__u64 tv_usec;
} __attribute__((packed));

struct v4l2_memout_timeinfo {
	struct v4l2_memout_timeval ktimes;
	__u64 timestamp;
} __attribute__((packed));

typedef struct {
	v4l2_srccap_vbi_init_cmd  enInitCmd;
	v4l2_srccap_vbi_init_type enInitType;
} v4l2_ext_vbi_init_para;

typedef struct {
	unsigned long long bufferAddr;
	unsigned int  packetCount;
} v4L2_ext_vbi_init_ttxslicer;

typedef struct {
	__u64 phyPacketPointer;
	__u8  u8Success;
} v4L2_ext_vbi_get_ttxdata;

typedef struct {
	unsigned long long RiuAddr;
	unsigned long long bufferAddr;
	unsigned int  packetCount;
} v4L2_ext_vbi_init_ccslicer;

typedef struct {
	__u8 u8lowerWord;
	__u8 u8higherWord;
} v4l2_ext_vbi_vps_data;

typedef struct {
	__u8 au8Data[V4L2_VBI_VPS_DATA_LENGTH];
	__u32 dataLen;
} v4l2_ext_vbi_vps_alldata;

#endif  // #ifndef __UAPI_MTK_V4L2_SRCCAP_H__
